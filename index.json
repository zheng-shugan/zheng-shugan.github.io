[{"categories":null,"content":"之前看 CS61B 的时候看到里面的第一个例子就是用 JUnit 来作为检查数据结构和算法有没有写错的验证程序，后来学了 Java 之后才知道 JUnit 是一个单元测试包，专门用来测试一些函数是否能得到预期的结果。但在学习 Web 前端的时候就一直没有看到过有教程或者是学习路线中有提到前端开发的单元测试要怎么写。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:0","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"为什么不能没有单元测试 单元测试的目的很简单，就是为了验证代码能不能按照编写的预期工作的，如果在写完一个函数就进行单元测试并通过就能更快的将问题排查出来，而不是等到项目运行的时候才去排错。 插一句不太相关的话，在平时的项目用 TypeScript 来替换 JavaScript 的一个很大原因就是希望将一些错误留在编译期间而不是项目运行时。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:1","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"为什么会是 Vitest 很简单，因为 vitest 的核心成员有 vue 和 vite 的核心成员，所以 vite 项目里集成 vitest 只要把 vite.config.ts 改成 vitest.config.ts 就可以将 vitest 引入已有的 vite 工程当中。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:2","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"准备工作 安装依赖 要在 vue 项目中加入 vitest 先要下载依赖： pnpm add @vue/test-utils jsdom vitest -D @vue/test-utils 是官方的测试工具库，jsdom 是拿去模拟 DOM 的，vitest 作为单元测试。 修改配置文件 vitest 是原生的 vite 框架集成起来是非常容易的，只需要替换一个配置就可以完成在 vitest 的集成。 /* 将 vite 的 defineConfig 换成 vitest/config 的 defineConfig */ import { defineConfig } from 'vitest/config' // https://vitejs.dev/config/ export default defineConfig({ // 其他配置 test: { environment: 'jsdom', // 指定虚拟 DOM 环境 }, }) 要测试什么？ 在测试之前我们需要知道希望某个组件预期会有什么效果。我准备的测试需要检查以下内容 Hello 组件根据 DOM 渲染出一对 \u003ch1\u003e\u003c/h1\u003e 标签 标签内部是否有文本 Hello Vitest Hello 组件 \u003cscript lang='ts' setup\u003e \u003cscript lang='ts' setup\u003e const props = withDefaults(defineProps\u003c{ msg: string }\u003e(), { msg: 'Hello Vue', }) \u003c/script\u003e \u003ctemplate\u003e \u003ch1\u003e{{ msg }}\u003c/h1\u003e \u003c/template\u003e ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:3","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"开始测试！ 创建测试文件 现创建一个 __test__ 的文件夹专门用于存放测试文件，然后在此文件夹里创建一个 Hello.test.ts 的测试文件。 创建一个测试 可以通过引入 vitest 里的 descript 函数来创建一个测试组，它接收一个字符串作为测试组的名字和一个函数进行测试。 describe('Hello.vue', () =\u003e { // 需要测试的代码 }) 在 descript 的回调函数中我们可以使用 vitest 的 test 来创建一个测试函数，同样的它也接受一个字符串作为测试的名字和一个回调函数。 describe('Hello.vue', () =\u003e { test('mount component', () =\u003e { // 需要测试的代码 }) }) 但在开始测试之前我们必须拿到需要测试的组件，我们可以通过 @vue/test-utils 里的 mount 函数做到这一点，它接收一个 Vue 组件和一些可选配置 /** * 创建一个 wrapper 包含需要渲染的组件 * @param Component 需要测试的组件 * @param options 可选项配置 */ function mount(Component, options?: MountingOptions): VueWrapper interface MountingOptions\u003cProps, Data = {}\u003e { attachTo?: HTMLElement | string attrs?: Record\u003cstring, unknown\u003e data?: () =\u003e {} extends Data ? any : Data extends object ? Partial\u003cData\u003e : any props?: (RawProps \u0026 Props) | ({} extends Props ? null : never) slots?: { [key: string]: Slot } \u0026 { default?: Slot } global?: GlobalMountOptions shallow?: boolean } 我们可以在 test 中拿到这个需要的组件 describe('Hello.vue', () =\u003e {describe('Hello.vue', () =\u003e { test('mount component', async () =\u003e { // 通过 mount 拿到一个包含 Hello 组件的 wrapper const wrapper = mount(Hello, { // 传入 Hello 组件的 props props: { msg: 'Hello Vitest', }, }) }) }) 验证程序 到目前为止我们已经创建好测试文件和拿到需要渲染的组件，接下来就是验证组件有没有按我们预期进行渲染。 现在就可以使用 vitest 中的 except 来验证组件的某些部分是否和我们预期的相同。现在 Hello 组件应该是只会显示标题 1 且文本为 Hello Vitest，所以我们可以这样做： const expectMsg = 'Hello Vitest' // wrapper.find() 来查找组件中的一个 HTML 标签 // wrapper.text() 返回一个元素的文本 expect(wrapper.find('h1').text()).toContain(msg) 到这一步我们的测试文件就写完啦，可以在终端里运行 pnpm run test 这样就完成了在 vue 中集成 vitest。 完整测试程序 import { describe, expect, test } from 'vitest' import { mount } from '@vue/test-utils' import Hello from '@/components/Hello.vue' describe('Hello.vue', () =\u003e { test('mount component', async () =\u003e { const msg = 'Hello Vue \u0026 Vitest' const wrapper = mount(Hello, { props: { msg: 'Hello Vue \u0026 Vitest', }, }) expect(wrapper.find('h1').text()).toContain(msg) }) }) ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:4","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"Useful Link Vitest | 由 Vite 提供支持的极速单元测试框架 Home | Vue Test Utils (vuejs.org) 测试代码 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:5","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"2022 年 12 月 22 号我不幸感染了 COVID-19，根据最新的中文叫法应该是「新冠感染」，不过我不想玩那么低级的文字游戏，所以就用 COVID-19 来称呼。 鼓励和推荐能接种疫苗的人群都应该去接种疫苗，接种疫苗是防护COVID-19 和降低对身体伤害最简单的方式 ","date":"2022-12-27","objectID":"/covid-19-review/:0:0","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"可能被感染的地方 在被感染的前一天去了超市 家人传染 房东传染 但不管是那种方式，反正最后是感染了哈哈 ","date":"2022-12-27","objectID":"/covid-19-review/:0:1","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"感染后 每个人感染之后的症状都不太一样包括但不限于：头疼、喉咙痛、咳嗽、咳痰、无力、全身发冷、嗜睡、出汗，但是可以确定是 COVID-19 绝对不是大号感冒。在感染期间我是只吃了布洛芬，家人也有吃对乙酰氨基酚片的，作用都是一样的，一定要大量的饮水，因为发烧出汗会带走体内的水分。有不舒服一定要及时用药和就医，不要小看 COVID-19 了，哪怕是感染之后康复也要戴好口罩避免重复感染 第一天 第一天起床就是明显的感觉头疼和没力气，但这个时候还没感觉是感染了，因为出门也是一直都戴着口罩的，就以为是普通的着凉然后头疼还没太当回事不过这前两年回来也会感冒或者头晕几天，然后下午睡了一觉和我妈也是同样的症状，这个时候才基本确定自己是感染了。 晚饭前就吃了两粒布洛芬，吃完晚饭后就精神多了但是头还是有点晕。睡觉醒来还是会一身的汗，在保证自己不冷的情况下穿宽松一些的衣服是比较利于人体散热的 关键词：头晕、无力、出汗、浑身痛 第二天 第二天的头疼就好很多了，早上就吃了一粒也是感染期间最后一粒布洛芬，在以为自己好的差不多的时候，我开始咳嗽了！刚开始这个咳嗽是真的难受，每次都是连着咳三四下，虽然咳的幅度不大但是也已经是我咳嗽过最严重的一次了。 伴随着咳嗽来的还有喉咙痛，我是在难受的吃了几个草珊瑚含片，确实有缓解喉咙痛的作用但不持久，我算是比较幸运的并不是「刀片嗓」，而且都是在咽口水的才会疼，吃饭的时候不疼😂 关键词：头晕、出汗、咳嗽、喉咙痛 第三天 这一天是感染以来最后一天因为身体不舒服而睡到十一点起床，继续咳嗽、咳痰和喉咙痛，但头疼和发烧的症状是都消失了，算是进入恢复阶段了。 关键词：咳嗽、喉咙痛 第四/五天 这两个天就基本没有感觉自己身体有哪里不舒服了，还是依旧居家不给他人带麻烦，咳嗽感觉是没有那么快好的了，不好人痊愈了也还是会咳嗽。 关键词：咳嗽、恢复 ","date":"2022-12-27","objectID":"/covid-19-review/:0:2","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"三个月后打疫苗 这次感染也不是特别意外，总有感染的一天只是时间早晚的问题，如果一直没有感染那当然是最好的啦，很倒霉是在这次感染是在第三针疫苗打完一年后感染的，这就意味着疫苗对我的防护力已经是大幅度降低。本来还想去接种第四针疫苗的，既然已经感染了那就等三个月后再去了～ ","date":"2022-12-27","objectID":"/covid-19-review/:0:3","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"配置的烦恼 每次用个新的工具链都要先看一下怎么换到国内源，要不然那个下载速度实在是太感人了，所以就打算收集一下 Web 前后端开发需要换源的工具链。 在这也感谢各机构备份镜像源，如果没有你们也就不会有这篇记录。 ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:1","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"系统设置 Homebrew Homebrew 是 macOS 下的一个包管理工具，可以很方便的去安装、管理各种开发环境和软件，如果你用的也是 macOS 作为开发平台 homebrew一定不可错过的一个好工具。 查看当前源： cd \"$(brew --repo)\" \u0026\u0026 git remote -v 替换为清华源： git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' \u003e\u003e ~/.zshrc source .zshrc ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:2","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"前端 Node 正式因为 Node 的出现前端才越来越组件化、工程化，Node.js 的发展也证明它不仅可以在前端发光发热，在后端领域也是有着不少合适的领域。 npm、yarn、pnpm 都是前端的包管理工具，个人更偏爱 pnpm 一点但是 yarn 在键盘上的位置更好按哈哈哈哈 npm # 查看当前源 npm get registry # 设置 npm 镜像源为淘宝镜像 npm config set registry https://registry.npm.taobao.org/ yarn # 查看当前源 yarn get registry # 设置 yarn 镜像源为淘宝镜像 yarn config set registry https://registry.npm.taobao.org/ pnpm # 查看当前源 pnpm get registry # 设置 pnpm 镜像源为淘宝镜像 pnpm config set registry https://registry.npm.taobao.org/ ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:3","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"Python 说到编程语言怎么能少的了 Python 呢，虽然纯 Python 的岗位不多但是 Python 上手真的是非常友好了。Python 也有着超多的第三方库，我完成的第一个小游戏飞机大涨就是用 Python 和 PyGame 写出来的。 pip 查看当前源： pip config list 替换为清华源： pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:4","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":" 如何入手一个开源项目 克隆到本地 安装依赖 pnpm yarn npm 看 package.json 主要看 script 和 dependencies 部分 从 App 组件入手，逐级往下看 ","date":"2022-10-20","objectID":"/to-use-opensource/:0:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"为什么要找开源项目 很多人在学完基础想要找项目的时候就不知道怎么找，有些是因为之前的视频看的都是培训机构的视频，如果当前这个培训机构的项目实战视频又有点老了或者是一些后端接口不能用的情况，当然这不是他们的问题，机构也需要为自己的发展做打算，一般能发出来作为视频教程的都是已经被机构内部淘汰出来的项目其他的基础教程也是同理。所以想把新技术都用上就只有去实现自己的一个 idea 或者是在 Github 上找到适合自己的项目。 我那时候就是这样的，看到机构的项目实战视频都有点老了，就自己去 Github 上找开源项目，找啊找终于是找到是纯前端的项目了。可就是咋样的都看不懂代码，于是我就从 components 文件夹开始抄，package.json 文件我就直接复制然后下载依赖，做完发现不对啊，我还是看不懂啊，怎么会这样，明明是把项目都抄了一遍，效果是出来了，但我咋还是不明白呢？ 能写下这篇文章就说明我已经是踩了很多坑之后，才明白的要怎么样从 0 开始入手一个前端的开源项目。这就来分享一下我在自学前端的时候遇到的坑～ ","date":"2022-10-20","objectID":"/to-use-opensource/:1:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"分析过程 一般在 Github 上 star 数比较多的项目都会有一个比较详细的 README 文档，一般包括以下几点： 项目介绍 项目特点 在本地如何开发 项目完成/没完成哪些功能 开源协议 这篇文章着重介绍如何在本地开发。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"在本地启动项目 首先入手项目的第一步肯定是想把项目下载到本地，一般都是 先把项目克隆到本地 git clone xxx example-project 然后紧接着就是安装依赖 cd example-project npm/yarn/pnpm install 最后再根据 package.json 里的命令把项目在本地给跑起来 pnpm serve/start/dev 这样就跑通了一个项目，安装依赖方面多说一句有时候用 pnpm 安装好的依赖可能跑不通，就换 yarn/npm 试一下。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:1","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"目录分析 在本地开发最重要的就是要看懂那些代码都做了什么，一般的前端项目都会有一个 App 组件在 Vue 项目里是 App.vue，React 则是 App.txs，入口文件则都是 main.ts。 在这我的建议是从上到下去分析目录，先看 package.json 了解一下项目大概都用了哪些依赖以及启动/打包项目的命令是什么，然后再去 main.ts 里看都引入了哪些组件和工具函数，最后就一步步的从 App 开始往下看。 有和后端联调的项目就去看看它都发了哪些请求、是怎么封装 axios 请求的，也可以用 postman/apifox 这样的工具去测试一下一些接口是返回什么数据的。 这个时候千万不要着急去动手写，看别人怎么写的代码是非常重要的，花个三五天甚至一周时间看代码看一遍都无妨。优质一点的项目代码量基本都不小，直接上手开始模仿人家的代码可能会直接晕掉。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:2","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"开始动手 在做了以上两步再结合项目介绍，对项目也已经有了一个更加清楚的认知了，这个时候就可以根据自己的需求是在原项目上添加一些功能还是说自己在学习的过程中发现了一些 bug 也可以试着去 fork 这个仓库去提 issues、去解决它。 在学习的过程中，最忌讳直接去抄代码的，这样做一遍下来可以说是毫无效果的，先思考这个页面做到这样的效果的，自己试试看能不能做一个最小实现的 demo。这样渐进的去学习做一个项目才是能收获到最多的。 很多东西是在看项目的时候是不知道的，这是很正常的。遇到没有用过的第三方包就去搜：npm + 包名，一些组件不知道怎么用就去查文档，英文文档看不懂？那就一边开翻译一边原文对着看啦。等自己的项目做完了好好的写一个 README 就算是完成了这个项目。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:3","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"总结 软件开发是个正向激励很快的工作，我的水平很次，但我很享受看到自己写的项目成果呈现在眼中去向朋友介绍我做了一个什么什么的网站，实现了什么什么样的功能，正是这些激励着我继续去做这件事。 ","date":"2022-10-20","objectID":"/to-use-opensource/:3:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"个人知识库搭建 为什么要搭建个人知识库 方便复习 方便分享 搭建知识库的需求 支持 Markdown 语法 云同步 好看 思维导图 流程图 没有广告 怎么搭建 写作软件 个人博客 总结 下学期就专升本考试了，恰好一直想整理一下自己的笔记，就想趁着这次机会学的知识都构建成一个知识库。 ","date":"2022-10-05","objectID":"/your-mind-palace/:1:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"为什么要搭建个人知识库 在没有搭建知识库学习的时候笔记文件总是这里一个哪里一个，检索麻烦不说还经常忘记在哪里，当我想复习的时候根本找不到笔记在哪。虽然有写博客的习惯，但写博客更应该是解决/分享某一个点而不是作为输出笔记的的地方，因为记录的都是笔记，能方便的发给同学看也是一点。基于以上两点我迫切需要一个软件来整理我的笔记！！！ ","date":"2022-10-05","objectID":"/your-mind-palace/:2:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"我的需求 在我眼里一个好的知识库需要具备这些条件： 支持 Markdown 语法 有思维导图 写作大纲 全平台云同步 无广告 好看 我愿意花钱在好用的软件上面。 ","date":"2022-10-05","objectID":"/your-mind-palace/:3:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"怎么搭建知识库 我的手机是 iPhone，电脑是 Mac，在这两个设备之间有个 iCloud 能很好的进行数据同步，但是我最常用的笔记软件 Typora 并不支持云同步，哪怕是把它写的文章都放到了 iCloud 中但是在 iPhone 上我也一直没有找到一个好用的 Markdown 编辑器，Bear 和 Ulysess 的定位也是写作软件作为知识管理软件也是费劲。其实我一直都知道 Notion 这个软件，但是由于其复杂的操作和云同步不是特别的稳定，所以 Notion 也被 pass 了。 恰好看到了语雀恰好这些功能语雀都支持，而且语雀还有 Web 版。体验了一段时间最重要的云同步也没有出现啥问题，虽然在语雀里写 Markdown 没有 Typora 那么爽但也无伤大雅，可以在本地写好在复制黏贴嘛。 虽然语雀也被官方定义为“小记”软件，本着一个软件只做一件事的想法，在使用语雀的过程中我只使用其知识库的功能。 ","date":"2022-10-05","objectID":"/your-mind-palace/:4:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"总结 虽然语雀可以解决的不只是知识库搭建的问题，但知识库最重要的是知识而不是用什么工具，工具只是方便了我们管理知识，要是没有语雀我用 txt 文本也能记录，就是没有那么方便一点而已，最重要的还是自己去学习啊。 ","date":"2022-10-05","objectID":"/your-mind-palace/:5:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"尾巴 语雀的出现让我对所有本地写作软件的要求高了一个层级，当一个软件的 Web 端都能有不错的用户体验之后为什么还需要一个本地 App 呢？只要同步功能做的足够的好在 Web 上写好的文档也能做到不丢失文档。能想象到未来会有越来越多的软件在 Web 端能做的越来越好，Vue 和 React 这类前端框架让 Web 端开发方便了太多。在 2022 年的今天，所有 Web 端体验做的不好的企业，只能说是对 Web 端一点都不重视，更不用说在手机上浏览某些网页的时候会有像“狗皮膏药”版的下载 App 的提示，真的是 Web 端体验不好吗？那倒未必是，很多人的工作用一个现代桌面浏览器就能解决。 ","date":"2022-10-05","objectID":"/your-mind-palace/:6:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"只要掌握编程语言中某一种某种思想，其实对于掌握其他的编程语言就已经打下了十分牢固的基础。但配置编程语言环境不是啊～ 幸运的是我学的第一门编程语言是 C 语言，第一次使用的 IDE 是 Xcode，安装完完整的 Xcode 之后会得到：GCC、Git 等各种编程需要用到的环境，让我在写 C 语言的时候十分的舒服。在我学习 Python 的时候，恰好电脑里又有 Python2 的环境，这也让我省去了配置环境的麻烦。 直到我开始学习《算法 4》，书中的使用到的库并不是 Java 的标准库而是作者根据书的需求写的，光是配置那个 Java 的环境变量就折腾了好久；然后又是 Pyhon 之间的版本差异又折腾了老半天。在使用 VSCode 配置 Go 编程环境的时候又搞了一小会，最后是在知乎上找到解决 VSCode 安装 Go 插件失败的问题才解决的。 最近开始学习 Ruby，系统自带的 Ruby 是 2.x.x 版本，而且系统自带的 gem 每次执行 gem install 就显示“权限不够”，意思就是要用 sudo gem install xxx 才行，而一条要用 sudo 就意味着它的不凡，可能是会对电脑造成不可逆的“伤害”（虽然我已经使用 sudo gem install xxx 安装了一个包），最后看了 Ruby China 上的如何快速正确的安装 Ruby, Rails 运行环境就解决了。 虽然不是对每门编程语言都很熟悉，但是电脑里还是需要有其的运行环境万一需要用到了嘛。在安装编程语言环境上 macOS 秒杀 Windows 18 条街，有 homebrew 真的少走了很多坑，如果是 Windows 估计我还在搜索引擎上找资料。 PS. 还是运行 JavaScript 方便，现代浏览器就可以～ ","date":"2022-09-13","objectID":"/aboutlearnnewprogramminglang/:0:0","tags":null,"title":"关于新学一门编程语言的痛","uri":"/aboutlearnnewprogramminglang/"},{"categories":null,"content":" 0基础想自学编程，不知道学前端还是后端还是其他，也不知道学哪种编程语言? 未来几年最有前景的三门编程语言是什么？ 大学生想学编程，想了解下python，C语言和Java？ 自学计算机该先从什么开始？如何自学？入门推荐学什么语言？ 在知乎看了一些计算机方面相关的内容之后，就能很容易的看到这些关于选择学什么编程语言好的话题/提问。刚开始接触编程的时候我也遇到过这样的问题，刚好最近开始学习 Ruby 借这个机会来说一下我对如何选择编程语言的看法。 ","date":"2022-08-31","objectID":"/aboutprogramminglanguage/:0:0","tags":null,"title":"第一门编程语言学什么好？","uri":"/aboutprogramminglanguage/"},{"categories":null,"content":"需要学 C/C++ 吗？ 在知乎问”如何选择编程语言“下经常都能看到： 建议先学 C/C++，之后再去学别的编程语言就会更轻松 事实其实也就是这样的，学习和实践 C/C++ 无疑是深入了解计算机系统的捷径但 C/C++ 中的指针也是真的不容易理解而且 C++11 之后各种新特性学都学不完，C/C++ 中最重要的就是指针的操作，这也是他们的看家本领，但对于每个动态 （malloc/new）分配的内存需要自己去考虑回收对于新手来说心智负担还是太大了。C/C++ 依然是非常优秀的语言，出色的实现了真实计算机系统的抽象从而最好的发挥了计算机的性能，但作为第一门语言来学习其实个人是不太推荐的，但深入了解却是能对计算机/操作系统有更多的了解。 ","date":"2022-08-31","objectID":"/aboutprogramminglanguage/:0:1","tags":null,"title":"第一门编程语言学什么好？","uri":"/aboutprogramminglanguage/"},{"categories":null,"content":"动态语言 VS. 静态语言 当需要用一门编程语言做一些实事的时候动态语言的开发效率总是要比静态语言来的要高，这也是为什么 Python 会这么火的原因，动态语言比起静态语言总是更容易理解，将一些强大但不好理解的功能包装好给开发者更好的体验。使用动态语言比如 JavaScript 利用 Node.js 只需要几行代码就能启动一个 web 服务器： import express from 'express' const app = express() app.get('/', (req, res) =\u003e { res.send('Hello World!') }) const port = 8080 app.listen(port, () =\u003e { console.log(\"Web serve running at 127.0.0.1:8080\") }) 如果是第一次学习编程建议还是先学动态语言比如：JavaScript、Python、Ruby，等入门了再根据需要学习其他编程语言也不迟。但话说回来其实对某一门编程语言比较了解再去上手别的编程语言也只是语法上的差异其思想都是差不多的，只要学了一门语言再学别的语言上手都会快不少的。 ","date":"2022-08-31","objectID":"/aboutprogramminglanguage/:0:2","tags":null,"title":"第一门编程语言学什么好？","uri":"/aboutprogramminglanguage/"},{"categories":null,"content":"一些小感悟 编程语言里没有银色子弹，需要找工作就学习市场需求量大的编程语言，对某个领域感兴趣就学习“领域专用语言”（DSL，Domain Specific Language）。 在今天这个时代，选择技术路线是一件关乎升生机的事情，是不存粹也不能存粹的一件事情。在各种场合都能看见各种程序员分析这 IT 行业的大局说在某方面比较优秀，掰着手指头细说自己所学技术的”钱“途，这都是些无可厚非的事情。我以前也是这样的，但后来发现其实争辩什么语言好/坏其实是件很无聊的事情，在工作选择适合的语言提高工作效率，私下写程序用自己欣赏的语言。 ","date":"2022-08-31","objectID":"/aboutprogramminglanguage/:0:3","tags":null,"title":"第一门编程语言学什么好？","uri":"/aboutprogramminglanguage/"},{"categories":null,"content":"const 是为了解决什么问题？ 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区的大小不再合适的时，很容易对其进行调整。另一方面，也随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以使用关键字 const 对变量的类加以限定： const int BUFSIZE = 512; 以上便是 const 在《C++ Primer》中的解释。 第一次看书的时候觉得 const 不就是定义一个常量用的东西，没啥好关注的。直到写出 const int x = 10; 和 int const x = 10 一时竟不知道其区别是什么，于是决定再翻翻《C++ Primer》看一下 const 的使用方法，也解决一下心中的困惑。（还顺便发现 LoveIt 主题一个 bug：代码块中不能识别 C/C++ 代码） ","date":"2022-07-31","objectID":"/aboutconst/:1:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的引用 可以把引用绑定到 const 对象上，一般称之为对常量的引用（reference to const)，和普通引用唯一不同的是，对常量的引用不能改变它所绑定的对象： const int obj = 1024; const int \u0026r1 = obj; // 正确：引用及其对象都是常量 r1 = 512; // 错误：常量引用不可改变其绑定的对象 int \u0026r2 = obj; // 错误：试图让一个非常量引用指向一个常量对象 int i = 1024; const int \u0026r3 = i; // 正确：对 const 的引用可以引用一个非 const 的对象 r3 = 0; // 错误：r3 是一个常量引用 ","date":"2022-07-31","objectID":"/aboutconst/:2:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 和指针 与引用一样，也可以领指针指向常量对象，类似于对常量的引用，**指向常量的指针（pointer to const）**不能用于改变其所指向对象的值： const double pi = 3.14; double *p2Pi = \u0026pi; // 错误：p2Pi 是一个普通指针 const double *cp2Pi = \u0026pi; // 正确：cp2Pi 可以指向一个 double 常量 *cp2Pi = 3.1415; // 错误：指向常量的指针不能用于改变其所指向对象的值 ","date":"2022-07-31","objectID":"/aboutconst/:3:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 指针 以上都是些开胃小菜，下面的内容会对 const 有了一个新的认识。 指针是一个对象，所以**常量指针（const pointer）**必须初始化，而且一旦初始化指针指向的地址就不可以改变了。把 * 放在 const 关键字之前就说明该指针是一个常量指针。 double pi = 3.14; const double *const p2Pi = \u0026pi; // p2Pi 是一个指向常量对象的常量指针 int num = 1024; int *const currNum = \u0026num; // currNum 将一直指向 num 这样的书写方式也隐含着：不变的指针本地的值而非指向的那个值。 想要弄清楚这些含义最好的方式就是从从右向左看。此例中：离 currNum 最近的符号是 const，意味着这是一个常量对象，下一个符号是 *，意思是 currNum 是一个常量的指针，最后的类型部分确定了常量指针指向对象的类型。类似的 p2Pi 就可以解读为一个指向常量的指针常量。 指针本身是一个常量并不意味着不能通过指针修改对象的值，能否这样做取决于指向对象的类型。 ","date":"2022-07-31","objectID":"/aboutconst/:3:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的位置 指针本身使用过对象，它可以指向另外一个对象。所以，指针本身是不是常量以及指针所指向的是不是一个常量就是两个独立的问题。用名词**顶层 const（top-level const）表示指针本身是一个常量，而用底层 const（low-level const）**表示指针指向的对象是一个常量。 double pi = 3.14; const double d = 2.0; // 不能修改 d 的值，这是一个顶级 const const double *p1 = \u0026pi; double *const p2 = \u0026pi; const double *p3 = \u0026pi; *p1 = 3.1415; // 错误：p1 是指向常量的指针（底层 const） p2 = \u0026d; // 错误：p2 是指针常量，不能修改指向的对象（顶层 const） *p3 = 10; // 错误：不允许改变 *p3，p3 是一个指向常量的指针 const double *const p4 = p2; // 靠右的 const 是顶层 const，靠左的是 底层 const const double \u0026r = pi; // 用于声明应用的 const 都是底层 const 如果是在变量中使用了顶/低层 const： const int x = 10; int const x = 10; 按照前面的定义可以说这两个声明的意思是一样的，定义了一个变量名为 x，值等于 10 的一个常量。两种方式都可以声明一个常量，我还是习惯于些 const int x = 10。 ","date":"2022-07-31","objectID":"/aboutconst/:3:2","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"函数中的 const 当形参是 const 时，如前面所述，顶层 const 作用于对象本身： const double pi = 3.14; double num = pi; // 正确：拷贝 pi 时忽略其顶层 const double *const p = \u0026num; // 错误：const 是顶层的，不能给 p 复制 *p = 0; // 正确：通过 p 改变 num 是合法的: =\u003e num = 0 和其他初始化过程一样，当实参初始化形参时会忽略其顶层 const。换句话说，当形参顶层有 const 时，传给它的值可以是常量也可以是非常量。 void foo(const int \u0026num); void foo(int \u0026num); // 错误：因为前一个函数顶层参数被忽略了，所以这两个函数的参数列表是一样的 ","date":"2022-07-31","objectID":"/aboutconst/:4:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"class 中的 const 函数 假设我们现在有这样一个 class： #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() { return stk.size(); } private: std::vector\u003cstring\u003e stk; }; 还有这样一个函数： int getStackSize(const Stack *stk) { return stk-\u003esize(); } 因为 stk 是一个 const reference 参数，因此在调用 getStackSize() 的时候应保证其不会修改 stk 的值，但是在 stk 上调用的每一个方法都有可能会影响 stk 的值，我们必须在成员函数上标注 const 来告诉编译器：Hi，编译器，在 Stack 对象调用 size() 方法的时候不会修改其对象的值: #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() const { // const 修饰符紧接在函数参数列表之后 return stk.size(); } private: std::vector\u003cstring\u003e stk; }; ","date":"2022-07-31","objectID":"/aboutconst/:4:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"从前后端分离开发说起 都说前后端开发要分离，而前后端分离的重点就是前后端独立可运行，那在后端接口没有返回数据的情况下来完成前端数据的获取呢？答案就是使用 Mock 数据来模拟预先与后端约定好的接口数据，来作为开发时的测试数据。 ","date":"2022-07-22","objectID":"/mockdata/:0:1","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"Mock 数据 什么是 Mock 数据 Mock.js 是一款模拟数据生成器，可以生成模拟数据来让前端开发独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据模版生产模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模版生成模拟数据 使用 Mock 数据 安装 yarn add mockjs 使用 import Mock from 'mockjs' const Dashboard = Mock.mock({ 'sales|8': [ { 'name|+1': 2008, 'Clothes|200-500': 1, 'Food|180-400': 1, 'Electronics|300-550': 1, }, ], cpu: { 'usage|50-600': 1, space: 825, 'cpu|40-90': 1, 'data|20': [ { 'cpu|20-80': 1, }, ], }, ... }) 这个项目所有的数据都是由 Mock.js 生成的，在 Umi 项目中，/mock 文件夹里的所有文件都被视为 Mock 数据文件。 在 /mock 里的文件，最后都有一行 module.exports = { } /mock/dashboard.js module.exports = { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) }, } 这段代码的意思是生成了一个 GET 方法，地址为 localhost:port/APIPrefix/dashboard 的后端接口，使用 Postman 等工具也可以测试的出来返回结果。 同样的也可以使用 ESM 来导出： export default { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) } } Mock 数据生成规则详情见 Mock.js wiki ","date":"2022-07-22","objectID":"/mockdata/:0:2","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"为什么要使用 TypeScript？ JS（JavaScript）是一门功能强大的语言，但是作为一门动态类型语言有时候简直是在浪费 IDE 强大的补全功能，就因为它是弱类型的语言，IDE 不能准确的推断出对象的类型，从而进行准确的提示。这一点对 VSCode 这种文本编辑器影响愈大。 TS（TypeScript）作为 JS 的一个超集，就和它的名字一样，为 JS 添加了 Type。作为一门静态语言，毫无疑问对 IDE 的语法补全有出色的帮助。别的优点不提，在 IDE 中的补全更强就是使用 TS 的一大理由，而且类型本身就是一种注释，哪怕需要添加更多的代码。 ","date":"2022-06-28","objectID":"/reactwithts/:1:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"在 React 中使用 TS 新建一个 React app 最简单的方式当然是使用 CRA 的 TS 模版了。 npx create-react-app my-ts-app --template typescript 打开项目，目录结构为： ├── README.md ├── node_modules ├── package-lock.json ├── package.json ├── public ├── src └── tsconfig.json 打开 /src 会发现 原来的 .jsx 文件的都变成了 .tsx。 ","date":"2022-06-28","objectID":"/reactwithts/:2:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"创建一个 TS 组件 import { useState, useEffect } from \"react\"; // Type with props export interface HelloProps { name: string; enthusiasmLevel?: number; } const Hello = ({ name, enthusiasmLevel = 1 }: HelloProps) =\u003e { const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } // Hooks with TS // 将 message 的类型设置为 string const [message, setMessage] = useState\u003cstring\u003e('') useEffect(() =\u003e { setMessage(`Hello ${name}` + getExclamationMarks(enthusiasmLevel)) }, [enthusiasmLevel, name]) return ( \u003cdiv\u003e \u003ch1\u003e{ message }\u003c/h1\u003e \u003c/div\u003e ); }; export default Hello; 注意到我们定义了一个 HelloProps 类型，它指定了这个组件需要用到的属性。在接受参数的时候我们为参数加上类型 HelloProps，一旦定义了类型，那么父组件就一定需要传递类型中的属性给子组件，否则将会报错。这样我们在 Hello 组件里接受到的参数就都是有类型的了。 同样的我们也可以选用类式组件 // src/components/Hi.tsx // 只是组件类型和 Hello.tsx 不同，其他都是一样的 import React from 'react' export interface HiProps { name: string enthusiasmLevel?: number } // React.Component\u003cHiProps, object\u003e 相当于 React 的泛型 // 这里的 HiProps 是 this.props 类型 class Hi extends React.Component\u003cHiProps, object\u003e { render() { const { name, enthusiasmLevel = 1 } = this.props if (enthusiasmLevel \u003c= 0) { throw new Error('You could be a little more enthusiastic. :D') } const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } return \u003ch1\u003eHello {name + getExclamationMarks(enthusiasmLevel)}\u003c/h1\u003e } } export default Hi 然后在 ./src/app.tsx 里把 Hello 组件挂载上就可以了。 import './App.css' import Hello from './components/Hello' import Hi from './components/Hi' const App = () =\u003e { const name: string = 'React.js' return ( \u003cdiv className='App'\u003e \u003cheader className='App-header'\u003e \u003cHello name={name} /\u003e \u003cHi name='TypeScript' /\u003e \u003c/header\u003e \u003c/div\u003e ) } export default App 这样就算是完成了使用 TS 来建立 React 组件啦。 ","date":"2022-06-28","objectID":"/reactwithts/:2:1","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"1. React 没有解决的问题 React 本身只是一个 DOM 的抽象层，使用组件构建 Virtual DOM。 如果需要开发大应用，还需要解决 组件件通信——组件之间如何交换数据 数据流——数据如何和 View 串联起来，路由和数据如何绑定？如何编写异步逻辑….. ","date":"2022-06-13","objectID":"/dvanote/:1:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.1 通信问题 React 组件有以下几个通信对象 子组件 父组件 其他组件 React 中向子组件传递信息可以直接通过 this.props 传递，例如： class Son extends React.Component { render() { return \u003cinput onChange={this.props.onChange}/\u003e; } } class Father extends React.Component { constructor() { super(); this.state = { son: \"\" } } changeHandler(e) { this.setState({ son: e.target.value }); } render() { return \u003cdiv\u003e \u003cSon onChange={this.changeHandler.bind(this)}/\u003e \u003cp\u003e这里显示 Son 组件的内容：{this.state.son}\u003c/p\u003e \u003c/div\u003e; } } ReactDOM.render(\u003cFather/\u003e, mountNode); ","date":"2022-06-13","objectID":"/dvanote/:1:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.2 数据流问题 主流的数据流解决方案有： Flux：单向数据流，以 Redux 为代表 Reactive：响应式数据流，以 Mobx 为代表 ","date":"2022-06-13","objectID":"/dvanote/:1:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2. dva 是什么 ","date":"2022-06-13","objectID":"/dvanote/:2:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.1 dva 应用的最简结构 import dva from 'dva'; const App = () =\u003e \u003cdiv\u003eHello dva\u003c/div\u003e; // 创建应用 const app = dva(); // 注册视图 app.router(() =\u003e \u003cApp /\u003e); // 启动应用 app.start('#root'); ","date":"2022-06-13","objectID":"/dvanote/:2:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.2 数据流 ","date":"2022-06-13","objectID":"/dvanote/:2:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.3 核心概念 State：一个对象，保存整个应用的状态 View：React 组件构成的视图层 Action：一个对象，描述事件 connect：一个函数，绑定 State 到 View dispatch：一个函数，发送 Action 到 State 2.3.1 State 和 View State 是存储数据的地方，收到 Action 之后会更新数据。 View 就是 React 组件构成的 UI 层，从 State 获取到数据之后，渲染成 HTML 页面。只要 State 有变化，View 就会自动更新。 2.3.2 Action Action 是用来描述 UI 层的一个事件 { type: 'click-submit-button', payload: this.form.data } 2.3.4 connect 绑定 State 到 View import { connect } from 'dva'; function mapStateToProps(state) { return { todos: state.todos }; } connect(mapStateToProps)(App); connect() 返回的也是一个 React 组件，通常称为容器组件。因为它是原始的 UI 组件的容器，即在外面包了一层 State。 connect() 方法传入的第一个参数是 mapStateToProps 函数，它会返回一个对象，用户建立 State 到 Props 的映射关系。 2.3.5 dispatch dispatch() 用来将 Action 发送给 State dispatch({ type: 'click-submit-button', payload: this.form.data }) dispatch() 不是从石头蹦出来的，而是被 connect() 的组件会自动在 props 中拥有 dispatch() 方法。 connect() 的数据又是从哪来的？ 2.3.6 Model // 创建应用 const app = dva() // 注册 Model app.model({ namespace: 'count', state: 0, reducers: { add(state) { return state + 1 } }, effects: { *addAfter1Second(action, { call, put }) { yield call(delay, 1000) yield put({ type: 'add' }) } } }) // 注册 View app.router(() =\u003e \u003cConnectedApp /\u003e); // 启动 app.start('#root') 数据流 2.3.6.1 Model 对象的属性 namespace：当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成。 state：该 Model 当前的状态。数据都保存在这里。 reducers：Action 处理器，处理同步动作，用来计算最新的 State。 effects：Action 处理器，处理异步动作。 2.3.7 Reducer Reducer 是 Action 处理器，用来处理同步操作，可以看作是 state 的计算器。它的作用是根据 Action，从上一个 State 算出当前的 State。 2.3.8 Effect Action 处理器，处理异步动作，基于 Redux-saga 实现，Effect 指的是副作用。根据函数式编程，计算意外的操作都属于 Effect。 2.3.9 Generator Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步还是同步）。 2.3.10 call 和 put dva 提供多个 effect 函数内部的处理函数，比较常用的有 call() 和 put()。 call：执行异步函数 put：发出一个 Action，类似于 dispatch() ","date":"2022-06-13","objectID":"/dvanote/:2:3","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"不知不觉从五月又到末尾了，随着年龄的增长新的一年收获到总是比过往一年的要多，而五月恰恰是一年里我最喜欢的一个月份，聊聊在 2022 年的 5 月我都做了些什么吧。 未来规划上： 在这个 5 月里我不断的问自己该学什么/做什么才能提升自己未来的竞争力。在现在 COVID-19 蔓延的情况下，伴随的是深圳封城、上海停工两个月、手机出货量大跌、互联网大厂裁员等等消息，作为一个即将要毕业的大大学生不得不担忧起自己的未来。 很遗憾，我并没有能力去改变这个世界，我能做的只有去投资自己。这也是我在大学生涯唯一能做的事情了。我不喜欢用“卷”这个词去形容一个人努力学习，都是成年人了，应该都会知道想现在做的每一件都是为了以后能够过上好一些的生活。所以我开始为了工作而学习，在这也分享一下我是如何知道自己该学什么的：找到自己喜欢做的-\u003e去招聘网站上看这个岗位需要满足什么条件-\u003e学习。这样保证了自己学习的知识都能帮到自己的就业啦。 生活习惯上： 看了老石的这期视频我开始听更多的播客，确实是收获到许多不一样的的视角，以前看待科技公司都是以爱好去看的只看和分析他们的产品，却没有深入去了解为什么这个公司能做出来这样的产品来，用碎片化的时间去开阔自己的视野真的是一件性价比十分高的事情。 现阶段做了什么： 5 月开了不少的 GitHub 仓库作为记录学习过程，基本上是把现在在学的东西都建了一个仓库。也开始学着给自己的项目写英文文档（虽然我英语真的很差😭）；学习方式也从之前的看视频转向看官方文档了，看个框架的教程长短四十小时，看完敲完差不多得两个星期，花时间不说，教程里的一些代码规范也远不如官方文档的。 总结一下 5 月的关键词： 了解大环境 了解自己该学什么才能提升自己的竞争力 投资自己 开阔视野 优化自己的学习流程 至于为什么不想着创业：顺大势，逆小势。 ","date":"2022-05-28","objectID":"/2022maynote/:0:0","tags":null,"title":"五月小记","uri":"/2022maynote/"},{"categories":null,"content":"Hi，作为一个初次学习 React 的小白在了解了state和props之后就可以快乐的在父组件中传递数据给子组件，然后在子组件里使用父组件的回调函数去修改父组件的state了。但是在兄弟组件再像这样传递数据就会变得很麻烦了，父组件需要分别传递回调函数和数据给两个子组件，然后子组件再调用相应的属性和回调才能传递数据。 比如说要实现一个在Search组件和List 组件之间传递数据： // App 组件 class App extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 更新 App 的 state；传递给 Search 组件 updateAppState = (stateObj) =\u003e { this.setState( stateObj ) } render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch updateAppState={this.updateAppState}/\u003e \u003cList {...this.state}/\u003e \u003c/div\u003e ); } } // List 组件 class List extends Component { render() { const {users, isFirst, isLoading, err} = this.props return ( \u003cdiv className=\"row\"\u003e { // 根据父组件中的 state 来选择展示页面 isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } // Search 组件 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 发送请求前通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, err: error.message}) } ); } }为了在两个组件之间传递数据我们不得不通过父组件`App`给两个组件传递函数和属性，明明是两个兄弟组件传递起数据来别别扭扭的感觉是有仇一样的组件之间的交流全靠父组件。这样在组件之间传递数据的方式决不是一个好的选择，于是乎就有了**消息订阅与发布机制**，[PubSub.js](https://github.com/mroderick/PubSubJS) 就是这样的一个工具库。 README 就有 Example 来知指导我们怎么下载和导入，在这就不多赘述。安装、导入之后就可以开始重构我们的代码了。 先考虑 App 组件。App 组件中的state部分是为了在两个子组件传递数据才设置的，现在可以直接在两个组件之间传递数据，而在Search组件中需要通过数据来更新展示页面所以可以把 App 组件中的state部分剪切到Search组件中；数据都到了Search组件中那么原来为了修改state的函数updateAppState也就不需要了；对应的也不需要再往子组件里传递props了。 class App extends Component { render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch /\u003e \u003cList /\u003e \u003c/div\u003e ); } } 接下来我们需要将Search组件中得到的数据传递到List组件。在这个关系中Search的发送方对应 PubSub 关系中的 puhlisher，List对应的是 subscriber。我们在这个项目中只需要知道怎么订阅和取消订阅即可，文档中对于的部分为 Basic example 和 Cancel specific subscription。 // 其中的 msg 是订阅消息的名称，data 是传递的数据 var mySubscriber = function (msg, data) { console.log(msg, data); }; // 先推送后订阅 // 推送一个订阅名称为 MY TOPIC 的消息，内容为 hello world! PubSub.publish('MY TOPIC', 'hello world!'); // 创建一个 token 接收来自 MY TOPIC 推送 var token = PubSub.subscribe('MY TOPIC', mySubscriber); // 根据 token 取消订阅消息 PubSub.unsubscribe(token); 在知道了怎么推送/订阅消息之后我们还要考虑什么时候订阅和取消订阅推送，正常的逻辑是在这个组件加载染到页面时才订阅消息，组件被卸载后就取消订阅。所以我们就可以在componentDidMount中订阅推送，在componentWillUnmount中取消订阅。到了这我们就可以放心的去重构List和Search中的代码了 List组件重构后 class List extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 组件被挂载时订阅 componentDidMount() { this.token = PubSub.subscribe('MY TOPIC', (msg, data) =\u003e { this.setState(data) }) } // 组件被卸载时取消订阅 componentWillUnmount() { PubSub.unsubscribe(this.token) } render() { const {users, isFirst, isLoading, err} = this.state return ( \u003cdiv className=\"row\"\u003e { isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } Search组件重构后 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, err: error.message}) } ) } render() { return ( // 页面内容 ); } } 经过测试重构后的代码的功能和原来的代码保持一致但是代码和逻辑都","date":"2022-04-21","objectID":"/react-component-communication/:0:0","tags":null,"title":"React组件间通信","uri":"/react-component-communication/"},{"categories":null,"content":"我自己拥有的第一台电脑苹果第一台搭载自研桌面级处理的 MacBook，2020 年它带着光环而来。搭载全新的 Apple Silicon、10 小时续航、统一内存、超低功耗、Rosetta2、桌面级处理器最先进的制程。其他一切都是原来的样子。加上了 T2 芯片的主板，意味着这台电脑从第一次开机的时候所有的数据都是加密过的，数据丢失就不可恢复。统一内存架构将内存集成到 SoC 上的做法彻底关闭了 Mac mini 升级硬件的大门至于 MacBook 已经习惯它不能自行升级任何配置了。所以只能买购买的时候花天价升级配置。我的MacBook 只把内存升级到了 16G 就多花了 ¥1500。 自 20 年 12 月以来我已经用了这台 MacBook 一年半的时间了。当我的室友在打王者荣耀的时候我用它学习 C++；当我的室友在考前突击的时候我用它搭建了个人网站；我在这台电脑上写下了第一篇博客，创建了第一个 steam 账号。 ","date":"2022-03-09","objectID":"/macbookpro/:0:0","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"Enter the macOS 不能说 macOS 比 Windows 好但是如果你是第一次接触电脑 macOS 绝对要比 Windows 更容易上手。 macOS Big Sur 之后的设计风格更加接近移动端 没有控制面板 开箱即用的触控板手势 大量的非线性动画 不需要找怎么显示桌面图标 更多细节快捷操作的操作 macOS 和 Windows 官网都提供相应的使用手册虽然里面的完成一些功能的步骤是有些复杂的但是对于初次上手的新手真的是非常友好了，有了这个就可以不用到什么论坛、微博、知乎去求助。可以说看完这个再结合自己的操作绝对比大部分的网友更懂 macOS / Windows。在初次上手时很多操作我就参考了《macOS 使用手册》，对应的 Windows 也有官方的文档《Windows 帮助和学习》。 ","date":"2022-03-09","objectID":"/macbookpro/:0:1","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"硬件完成度 从 MacBook Pro 2016 到 MacBook Pro 2020 的外观几乎是没有变化，没有变化说明现在的模具稳定性没有什么大问题了但这个模具真的是用了有点久了。几乎一致的模具的内部藏着的就是本次最大的升级： Apple Silicon on Mac 统一内存架构 第一颗 5nm 桌面级处理器 MacBook 最强的集成显卡 雷电4 / USB 4 一天办公需求的续航 十分冷静的核心 大部分的场景下可以把搭载 M 系列的 Mac 当作之前搭载 Intel 的 Mac 一般使用只是发热低了许多。M1 没有因为功耗低在性能上做出太多的妥协，在你需要性能的时候它也不必之前的 MacBook 弱；更强的能耗比表现使其续航可以满足一天的办公需求。M1 芯片使得 MacBook 在市场成为一个独特的存在也走出了自己的一条路。需要注意的是 M1 独特的硬件架构不是适合所有人，在买所有 Mac 之前一定要清楚自己拿电脑是来做些什么的，一些人用上 M1 或许能让生产力提高；一些人或许面对的就是需要的软件在这个平台上根本没有。也不是所有的人都用的惯 macOS。 用了这么久的 M1，发现它的性能对于我来说现阶段是发挥不出它全部的实力除了觉得内存有点不太够用（选 Mac 时有预算尽量还是加在内存上；如果是定点办公闪存用靠雷电接口外接一点问题都没有）其他方面真的是非常够了。 今天看到了 M1 MAX 胶水拼接成了一块 M1 Ultra，在 2020 年我绝对想不到 M1 系列能如此的残暴：初次登场轻薄本中无敌的能耗比；Pro 、 Max 大幅度升级 GPU；最后的 Ultra 直接 Fusion。M1 都到 Ultra 了都没登陆到 Mac Pro 上或许下一代还有定位更高的？可能吧，让我们一起期待下一世代的 Apple Silicon。 ","date":"2022-03-09","objectID":"/macbookpro/:0:2","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"软件完成度 有自己的操作系统就是舒服，早在 2005 苹果就推出了 Universal Binary 和 Rosetta：为了从 PowerPC 过渡到 Intel 做准备。当时从 ARM -\u003e X86 的经验也让这次 X86 -\u003e ARM 变的更加的顺利，最明显的一点就是在搭载 M1 的 Mac 一发布就有不上第三方的软件完成了原生的适配。不仅如此，在 App Store 里还可以下载 iOS/iPadOS 的软件了虽然不是所有软件都支持但至少有了可以做到的能力，让 macOS 的生态和移动端更加紧密。（说句题外话：也希望能在未来的 WWDC 上看到 iPadOS 中能有更多关于内容生产的部分吧，去年的 iPad 的 playgrounds 已经可以写 swiftUI 的软件就是一个很好的开始。） 说完了为了 Apple Silicon 做出的适配再说说 macOS 本身。macOS 本就是一个 Unix 系统，自带的终端就默认的shell就是zsh。 在 Mac 上的 homebrew，可以直接通过终端下载软件和环境如果缺少对应的依赖也会自动下载好。比如这个博客的框架就是用 homebrew 下载的：brew install hugo，一行命令即可。 再来就是 macOS 中安装 Window。曾经我也对这个充满疑问：为什么在 macOS 里还要安装 Windows？？？后来才知道是我年轻了 —— 一些软件在 macOS 里根本没有。 如果你是大学生在不知道自己未来的学习需要用到什么软件的时候最好还是选择购买一台 Windows 的电脑，因为无法保证每个人都买得起 Parallels Desktop 虚拟机安装 Windows，买得起 Parallels Desktop 也不能保证需要的软件能运行在 arm 架构上或者说是流畅度可用。虽然的 M1 的 Mac 能耗比的优势巨大但是之前的 Intel Mac 还是有优势在的如果你需要那样的生产环境 Intel 的 Mac 还是很值得购买。 除却 Rosetta2 和 Universal Binary 之外 macOS 也从原先的拟物化设置变为了和 iOS 一样的扁平中带些拟物的化设计，比起之前更像移动端的设计风格了也让我这种 macOS 小白在 2020 年第一次使用 macOS 都没有感到一丝的不适应，至少不会出现不知道在哪显示桌面图标…… 不过当然了该有的 bug 一个都不会少：中文输入法卡顿、Safari 闪退等等问题（具体的问题根据使用场景的不同也都不一样）。如果安装了 beta 版的操作系统会更加的糟糕，不过没事别升级 beta 版系统。 ","date":"2022-03-09","objectID":"/macbookpro/:0:3","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"体验和感受 用了这么久的电脑早就习惯了它的操作逻辑也已经没有了刚拿到上手的新奇劲，现在就把它当作一个无情工具使用，性能够用、便携、续航强、编译起代码来一点都不哆嗦。电脑买来总是拿去干活的，如果它能让你工作流的效率提升那就买吧多赚的钱都购买好几台了电脑了。我现在希望的是它不要出问题：苹果的维修价格实在是太感人了。 我听说新 Mac 是造梦引擎，可我手机的这台已经是了呀！ ","date":"2022-03-09","objectID":"/macbookpro/:0:4","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"从高中开始就很想搭建一个自己的博客网站觉得这是一件特别酷的事情：在自己的网站上介绍自己的作品、分享自己产品体验又或是记录自己的碎碎念……虽然每次建站都会遇到坑但把从网站 localhost 推到 GitHub Pages 还是很高兴的。 之前的博客框架是 Gridea，每次同步都很糟心处于一种薛定谔的状态不过 Gridea 还是很适合少折腾专注写作的小伙伴。这次建站就换成 Hugo 来驱动，Hugo 是由 Go 语言编写的静态博客框架，可惜的是想要的域名在国内无法备案、Github Pages 在国内的访问处于一种很迷的的状态，不过这都不影响我写博客之后会在本站上更新一些自己做的小项目和数码产品的体验以及碎碎念。 祝我玩的开心！ ","date":"2022-02-11","objectID":"/helloworld/:0:0","tags":null,"title":"Hello world","uri":"/helloworld/"}]