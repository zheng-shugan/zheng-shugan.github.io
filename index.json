[{"categories":null,"content":"临近毕业才感觉大学是巩固自己三观的一个过程，每一年对自己、社会、世界的认识都会不一样，可能每一年都能感觉自己上一年是无比幼稚的。在这期间才是成长最快的时候，因为要对自己的未来负责，要找到自己匹配的社会角色，也是一个认识自己、改造自己的机会。很可惜当年高考只能去读专科，如果能考一个本科说不定第一份工作的起薪还能更高哈哈。 关于面试和入职 入职的公司加上我只有 7 个人，面试也只有一轮还是老板亲自面试的。反正我是在这次面试和入职之后学到了很多东西，反正是课堂老师从来没有说过的哈哈。 面试的过程很常规：笔试题 -\u003e 介绍公司背景、业务 -\u003e 入职问题 -\u003e 薪资问题 比较关键的问题有： 五险一金的比例？ 试用期有多久？ 有无食补、餐补？ 加班情况怎么样？能 1 : 1 调休吗？ 每个月工资什么时候到账？ 我司的五险一金转正了之后才有但按照最低标准去交（可能会更高一点，但绝不会达到当前薪资对应的水平），十三薪是按转正之后工作月 / 12 * 月薪这样计算的。 工作有分实习期、试用期、正式员工。校招、秋招、春招都是单位的实习岗位对应的是实习生。等毕业拿到毕业证后就可以和公司签署劳动合同，一般会先和公司谈转正后的工资和签署劳动合同，然后就是 3 个月的试用期（根据劳动合同年限的不同，试用期时间可能不一样），试用期结束后就可以解除试用期的合同，签署正式的劳动合同。 岗位 薪资 五险一金 实习期 低于试用期 无 试用期 转正工资的 80% - 100% 无 正式员工 转正工资 + 薪资 有 还有签合同的时候要在身份证上写仅供 xxx 公司人事部门备案使用，要记得横跨身份证复印部分（这样避免签名部分被撕掉），所有合同都要认真看然后让公司盖齐缝章（避免合同内容被替换）。 开发幸福感 工作内容是用 Odoo 框架做企业的 ERP 系统，虽然是用 Python 做后端但是对 Python 的要求不会太高，遇到公司的几个同事都是看视频和文档一周之后就开始上手写需求了，做的最久的一个还是毕业之后转行现学的，工作两年多已经成为公司的二把手了。计算机真的没有什么门槛，万物可转计算机不是开玩笑的。 用 VS Code 的好处就是同事帮忙调试代码的时候比较方便，坏处就是智能提示做的没有 PyCharm 那么好一些。但 Odoo 开发也不用什么代码提示，遇到的字段基本都是复制粘贴还有查找，反而 VS Code 的启动速度成为了开发的优点，第一次写 Python 没有感觉 PyCharm 没有优势。 比起什么框架、编程语言，显示器对生产力有更直观的影响。老板之前就是做开发的所以给员工配的都是 24 寸双屏显示器，美中不足的就是分辨率只有 1920 * 1080，这个分辨率实在是太低了，我 13 寸的笔记本分辨率都 2560 * 1600 了，缩放放大吧代码有看不见几行特别是横向的显示内容，更加坚定了显示器的 PPI 要 159 起（对应的是 27 寸 3840 * 2160 的显示器）。但这家公司已经很不错了，上班不需要自己自带电脑，不像之前去的那个工资更低而且还要自带电脑，小气死了。 在这里也吹一下 Ruby 和 Python 这类编程语言的 Active Record，为数据库添加一个字段只要在 Model 做出修改重启项目数据库就会自动添加。比起 Java 那样手动的去创建数据库然后添加字段要在实体类和数据库里两边操作的狗屎操作不知道高明了 210983 倍。还是要吐槽一下 Odoo 模块升级的时候那个速度实在太慢了，查看资源管理器也 CPU 和内存占用也不高，属于是性能低且性能利用率低… 关于需求 ERP 系统开发也算是外包的一种所有的需求都是来自于其他的公司，所以就会经常看到一些描述很奇怪的需求。客户自己可能都不知道这个功能需要怎么样去完善的，或者是不知道他们需要的流程到底是什么样子的。很多时候给出的需求文档都是让人摸不着头脑都要自己再理清一下才能开始动手。 作为一个纯纯外包公司，但客户的公司也不是完全没有写代码的。对接过最复杂的一个项目需要协调两个系统某个模块的互通，开发人员有我和对方的一个姓卢经理但需要协调的有四个部分的人员，那叫一个复杂啊。而且作为一个多人开发的开发的项目他们居然让我直接在 master 分支上修改代码，然后进度没做完就让我们把代码剔除了。在这里说一个暴论：多人合作项目在 master 分支上开发无一例外都是傻B，卢贤平你是我见到的第一个。 按道理客户懂得开发对接起来应该会很舒服，至少沟通起来障碍少了很多。好吧，在经历了这次开发之后才明白客户懂代码只是锦上添花罢了，开发和对接会不会愉快还得看对方能给出什么样文档和对接人员。 第一次对接客户的时候那个时候以为他们说需求很着急，但是那个时候很菜当然了现在还是很菜根本不能按时完成的时候那个时候就有点紧张了，那段时间真的非常不想上班感觉去了需求又做不来，基本做一个就要问一下同事怎么做，一些流程也不确定一直和客户那边沟通，因为是两个系统的互通所以我要和两边的客户沟通。 关于加班 刚到公司我都是六点准时下班的，老员工也最晚也只做到七点就下班了（因为上班一直被我叫去解决 bug）。这也是运气比较好，总是能在下班前把手头上的某个需求给做完哈哈。 等到有某些功能着急上线的时候就都会适当的把任务多推进了一点再走基本也就是六点半就走人，最晚的一次是到七点才走。 关于臭写代码的 臭写代码的。这个称号是在上班之后对自己的称呼，每天的需求其实就是修改一些数据库的字段，把某个内容显示到表单上（企业内部系统尤其如此）也就是 CRUD 哈哈。做完需求没事干就摸摸鱼，有需求就继续看代码写代码。 技术上肯定是没有什么进步了虽然我也不认为什么高并发就是高级东西但业务能力还是有在增强的，看到他们都是自己对接客户商量需求。好像去什么公司都是这样的无非是需求是哪里来的，是在公司内部来的就是自研，来自外部的就是外包。 在公司就是维护现在运行的项目然后继续在屎山上堆集代码，代码和人有一个能跑就行。 尾巴 上班之后的时间过的很快，每天干的事情也都差不多。感觉已经慢慢失去写代码的激情了，可能需要再去学一些有意思的东西了比如一直想学的 Ruby、Ruby On Rails、Angular，可能不是那么有用但更符合自己的审美吧哈哈。 把学到的东西真实的转为工资才能体会到其中的不容易。在工作中哪怕是完成需求之后开始摸鱼之后也不会获得成就感。就更难想象一个人工作日都是到 9 点下班回到家快 10 点的情况得有多可怕，**拒绝 996 从毕业做起！**现在无比庆幸在高考后没找到兼职，工作的苦未来能一直吃，但那无忧无虑的时间是真的是一去不复返。而且兼职那所谓的社会实践对自己毫无帮助，如果不是家庭条件不允许一定需要靠兼职才能读得起大学的情况一点都不建议高考后去做兼职。 也不必说公务员就是一眼望得到头，写代码不也是如此吗？今年可能是未来十年臭写代码最好的一年。虽然找到工作之后我爸没有再说计算机是个垃圾专业了，但我开始觉得计算机是一个『垃圾专业』了。 ","date":"2023-07-29","objectID":"/first-job/:0:0","tags":null,"title":"找到工作了！","uri":"/first-job/"},{"categories":null,"content":"在福州职业技术学院这的三年抱怨过无数次学校为什么这么垃圾、老师怎么又做妖、食堂没什么东西吃、学校好小、水课好多等等，真的要走的时候反而舍不得起这三年的时光了，可能怀念的是大一是的不知天高地厚也可能是大二在机房的考试周，最有可能的是大三面对现实前的摆烂和狂欢吧。 像良棋上次说的那样：你到了新的宿舍关系未必能有我们现在宿舍这样。友谊不是说有就有的，或者说是现在的我不是很想去接触一段新的朋友关系，上班的同事也只是吃饭的搭子并没有什么可以聊的合租的室友也只是普通朋友罢了。 未来能不能再见是不可知的事情了。和恬微的见面是见一面赚一面，和大多数朋友的见面那是见一面少一面了。所以好好说再见，祝愿我们都有美好的未来。 在和恬微的电话中说道：其实我舍不得的不是这个学校而是一起成长和见证成长的人。 为什么每次都是到最后大家才惺惺相惜，吐露出舍不得的情感？只有到了最后我们的目标才能达成一致，只有目标一致才有话说，才能互相敞开心扉。所以我们才要好好说再见，好好的说出心里的舍不得，说出心里的祝福。难忘的是我们一起变得成熟，难忘的是我们要分别，难忘的是好好说了再见，所以不能忘记。 福州职业技术学院 4 号楼 510 的钱朝瑞、姚冰、李鑫、黄文磊、肖良棋、许以孚，就此别过了。好好说再见，就把成长的经验留在那一个小小的八人间内吧！这三年懂了很多的知识，回到宿舍总有人能开开玩笑也算的上是轻松。 ","date":"2023-06-24","objectID":"/i-graduated/:0:0","tags":null,"title":"我毕业了","uri":"/i-graduated/"},{"categories":null,"content":"专科、计算机，可以说是在招聘的时候叠满了 debuff，只要本科的公司已读不回要专科的基本都是未读，好不容易有几个面试邀请也还都是外包公司，好的是 3000 + 986，差一点就是 2500 + 966，这念头你还无脑冲计算机吗？ 就计算机的校招而言，个人的毕业设计在面试的时候能起到关键的作用，连续几次面试都没有看简历上的项目经验但都问了我毕业设计做的是什么，进一步的问我项目是不是跟着视频做的。是不是实战项目也很容易看出来。 外卖项目 商城项目 点评项目 博客项目 秒杀项目 后台管理项目 大部分微服务项目 这些都是实战项目的重灾区，去 B 站上都八九不离十都是这样的项目。其中也只有博客是最不容易被怀疑是跟着教程做出来的，其他的都是一眼假的项目。 我也不是一个对自己高要求的人，但做出这种项目写在简历上也还是有些怕面试官深挖的。大部分的技术都写的太高大上了，比如用 Redis 实现了分布式锁。可最多就在跟着那个项目的时候做的时候更着教程做了一次，其他时候没有应用场景哪里会去用这样的技术，只能说是学过了这个技术而已。 如果我是面试官，校招的时候侧重点也肯定是问毕业设计做的是什么，有做过两个项目就可以至少会知道要怎么用编程语言去做开发了多了容易露馅。 博客项目虽然烂大街但还是一个值得做的项目，有没有部署到服务器，有没有写博客这些都是项目的亮点，大不了把简历的字体、行间距、段间距挑大一些能写满一张 A4 纸就可以了。 好好做一个毕设不仅能在学业上拿一个高分也能在简历上好好的写一笔自己的项目经历，怎么说都是一件不亏的事情呀。 ","date":"2023-06-12","objectID":"/about-graduation-project/:0:0","tags":null,"title":"好好对待你的毕业设计","uri":"/about-graduation-project/"},{"categories":null,"content":"Intro 如果说大学是教人掌握知识的地方那么 B 站可以说是中国最普适学生最多的学校了，一个没有广告、各个学科的课程都有的地方很难让人不接受。我的编程就都是在 B 站上看教程学习到的，我也敢说我在 B 站上学习到的知识要远比在大学课堂里学到的要更多。 ","date":"2023-06-04","objectID":"/good-projects/:1:0","tags":null,"title":"怎么样才算一个好的项目","uri":"/good-projects/"},{"categories":null,"content":"甜蜜期 我开始在 B 站上学习各种 Web 开发的知识，Vue、SpringBoot 各种和课程配套的资料最麻烦不过去公众号获取百度网盘的链接。一个 Vue 教程有 60 多个小时，JavaScript 教程有 20 小时。 大一和大二封校的时间还是比较多的，学习这些教程占据了大部分的学习时间，从入门到实践项目。 在自学的这段期间，我用 React 写了改写了自己的博客，从原来的 hugo + GitHub Pages 到 next 和 Vercel，从原来很讨厌小程序和 uniapp 到主动去找相关的资料。照着招聘网站上的技能要求在 B 站上找的相关技术，我能找到工作 B 站和培训机构的教程是功不可没的。 ","date":"2023-06-04","objectID":"/good-projects/:2:0","tags":null,"title":"怎么样才算一个好的项目","uri":"/good-projects/"},{"categories":null,"content":"问题初现 可以说 B 站带给了有参加工作能力的机会，但也止步于此了。诚然培训机构能出免费的项目实战项目视频就已经算是不错了，他们的生意好坏也取决于项目的质量如何，做了几个发现了他们的一些问题： 不遵守 xxx 代码规范 喜欢用自己写出的轮子而不是社区的解决方案 项目的实际上线意义不大（上线也只是一个演示效果） 其实我一直在想为什么一个大学毕业生要做一个商城项目呢？更别说外卖项目和各种后台管理系统了。而且很重要的代码规范在项目实践中都不演示。更别说一些教程的人喜欢用自己封装好的工具类，用就用吧但是你不发布到 npm 或者是 maven 上。我不否认把自己代码拿去变现这反而是一件好事，花钱就能获得更好的学习体验这对双方都是更好的。 很长一段时间里我不知道自己该做什么东西好，于是我开始迷茫。我到底适合计算机吗？为什么我要做这样的东西？我也不知道到底做个什么好，于是我只好去做这些项目，虽然不知道为什么要做这样的项目，但还是收获到不少的开发经验，可能这对大学生来说就已经是够了吧。 ","date":"2023-06-04","objectID":"/good-projects/:3:0","tags":null,"title":"怎么样才算一个好的项目","uri":"/good-projects/"},{"categories":null,"content":"做适合自己职业发展的 很多人都说做要做适合自己的，但其实很难找到适合自己的项目，这句话就成为了废话。当我开始找工作的时候这些问题就有了答案：适合自己职业发展的。 Web 前端比较适合自学和入门至少能写一个静态博客，静态博客是一个前端初学者最值得做的一个项目。为什么不是动态博客？在写博客的时候为什么还要多个后台管理系统呢对吧。 后端就麻烦了一点了就一定需要有一个具体的需求才能做出一个项目来，但好在 Java 的培训班足够给力，如果真的不知道做什么好那就按照他们的实战项目按照口碑从高到底做 2-3 个就可以了。 我接下来的目标也就是试着去寻找自己生活中的痛点然后去做个工具解决的。虽然可能做不到，但做到了对我是没有坏处的，时间花在哪里不是花呢。 ","date":"2023-06-04","objectID":"/good-projects/:4:0","tags":null,"title":"怎么样才算一个好的项目","uri":"/good-projects/"},{"categories":null,"content":"JavaScript 里面的函数是我学过的编程语言里面最奇葩的一个，没有之一超第二很远。 写一个函数去操作数据就是为了方便和可复用，但 JavaScript 的 function 保留字定义的函数让我感觉把写代码的心智负担提升了一个等级。我觉得去纠结一个函数 this 指向的问题太浪费时间，就像本来我还想为这篇博客写一个案例来看看 function 保留字定义有多糟糕，但这个时间好像是无意义的，不如直接说出我的结论：放弃使用 function 来定义函数，全部使用箭头函数吧。 ","date":"2023-05-06","objectID":"/why-not-function/:0:0","tags":null,"title":"放弃function保留字","uri":"/why-not-function/"},{"categories":null,"content":"很难忘记在学第一门编程语言配置环境时候狼狈的样子：又是下载 GCC 又是配置环境变量的，等到终于学完语法基础了，工程化的时候依赖/包管理又是一件很烦的事情。 大学三年了，对学习编程语言也有一些经验了。大概就是 用系统包管理器安装环境 配置环境变量 掌握依赖/包管理 在这也说说学编程语言以来的几个经验 ","date":"2023-04-08","objectID":"/programming-experiencev1/:0:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"代码规范 不知道为什么很多网课和教程都不讲各种语言的代码规范，但这是写代码中很重要的一部分，在学完一门编程语言的顺序结构、分支结构、循环结构和函数之后就可以开始把代码规范引入了。 如果是学第二门编程语言建议一开始就去了解一下某个语言的代码规范是怎么样的，这样保证了在自己的项目里写的代码不至于一下就忘记是拿去干什么用的。 ","date":"2023-04-08","objectID":"/programming-experiencev1/:1:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"JavaSctipt 学习 JavaScript 只推荐两本书和一个网站：《DOM 编程艺术》和《你不知道的 JavaScript》，和 MDN 的 JavaScript 文档。 学习 JavaScript 一定不能离开 DOM，现代所有前端框架都是以 DOM 为基础来构建的，很多人说自己的 JS 基础不好很大一部分原因就是因为没有好好了解 DOM。 《你不知道的 JavaScript》里很好的描述了如何避免 JS 的垃圾设计带来额外的心智负担，也是这本书让我看见了 JS 是多么的丑陋。 可以吧 MDN 理解成一本《JavaScript 高级程序设计》和《JavaScript 权威指南》的网页版。虽然在内容的顺序上有些不太一样，但三者的特点都是 JavaScript 的百科指南，可以当作工具书来用是非常好用的。 代码规范这个的东西一定要从开始学代码就开始养成，特别是对于 JavaScript 这样动态弱类型的语言，没有一个严格的代码规范很容易写完代码过一周就不知道自己写的是什么了。 ","date":"2023-04-08","objectID":"/programming-experiencev1/:2:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"TypeScript TypeScript 的类型系统真是是强大但复杂，想要写出好的 TypeScript 类型还是比较麻烦的，很考验类型体操的能力。 比如 const foo = \u003cT extends any\u003e(n: T) =\u003e { console.log(n); } foo('Hello TypeScript') 和 const bar = (n: any) =\u003e { console.log(n); } bar('Hello TypeScript') 这两个函数乍一看感觉是一模一样的，但第一个的 IDE 提示要远比第二个要好的多。 作为全栈开发这你可以用 nestjs 来做后端，支持 TypeScript 的前端框架那更是数不胜数，如果你的精力有限又想做自己的产品，TypeScript 会是一个很好的选择。 但不要指望用了 TypeScript 就可以不要写代码文档了，代码好不好维护很多时候和语言没有什么关系，更多的是在于写代码的人的规范是怎么样的。 ","date":"2023-04-08","objectID":"/programming-experiencev1/:3:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"Git git 可以说是最劝退新人的一个工具了：不熟悉的命令行操作、网络环境、环境配置。这些问题很容易就能把一个小白给直接劝退了。 在个人项目里用 git 最大的好处就是备份文件了，只要多多 commit 基本不用担心不小心把文件删了该怎么办、多写了几行代码项目突然不能运行了不会回滚的惨剧。 ","date":"2023-04-08","objectID":"/programming-experiencev1/:4:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"包管理工具 不管你是想做前端还是后端开发，等到学习项目工程化的时候包管理工具是不可避免要接触的。包管理工具就是让我们更加方便的去使用别人已经写好的代码，只要敲几行命令、配置一下文件就能下载到别人发布的代码。 比如 Java 的 maven 和 gradle，JavaScript 的 npm 还有 Python 的 pip 等等。 但更方便的是用系统的包管理工具，大部分编程环境的依赖下载好的同时就能帮我们把环境变量给配置好，简直是一举两得啊，我忘不了在第一次学 C 去配置 GCC 环境在各种配置里跳来跳去的惨剧啊…… 在这也推荐几个常用的包管理工具 macOS：homebrew Windows：chocolatey 各个 Linux 的发行版都有自己的包管理工具，用官方自带的就可以了。 想要方便的使用记得一定要换一个国内的镜像源，或者是配置一下系统终端的科学上网代理。 ","date":"2023-04-08","objectID":"/programming-experiencev1/:5:0","tags":null,"title":"编程经验 v1.0","uri":"/programming-experiencev1/"},{"categories":null,"content":"最近都在准备升学方面的东西，越来越觉得 AI 可以代替我了。 因为我背书是不可能会背的过 AI 的。 不论如何，我们不应该再去重复那些 ChatGPT 或者是其他 AI 能够完成的工作。 ","date":"2023-04-04","objectID":"/alt-ai/:0:0","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"ChatGPT 是如何促进我的生产力的 ","date":"2023-04-04","objectID":"/alt-ai/:1:0","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"可靠性高一些的搜索引擎 比如今天我搜了『三角函数六边形记忆法』，如果是用 Google 或者 Bing 来检索我需要在他们给出的答案里再次判断一下他们的信息里有多少噪音。而 ChatGPT 能直接告诉我三角函数六边形记忆法的定义和用法，仅此而已，没有其他任何多余的信息。 ","date":"2023-04-04","objectID":"/alt-ai/:1:1","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"生成 Python 代码 上周开始我用闪卡来整理需要背的政治内容，然后导出的时候发现只能导出为 CSV 和 PDF 文件，这两个文件都不能很方便的导入到其他类似的 Anki 客户端，所以就去问了 ChatGPT 问他要怎么把 CSV 里的文件读取出来生成一个符合 Anki 规范的文本格式，它生成了一个 Python 函数，结果我只花了 5 分钟不到的时间就完成了这件事情，我也能把自己整理好的资料分享给别人了。 ","date":"2023-04-04","objectID":"/alt-ai/:1:2","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"要怎么去看待 AI 以前大家一直认为，AI 以后最难替代的就是艺术类的工作者，因为艺术这种东西是带有感情在里面的，但是去年 Midjourney 和 Stable Diffusion 却直接让他们大大减少了完成相同工作的时间。 ChatGPT 的通用性更是让大部分人都有了参与这个话题的机会。可能很多职业真的会被代替了，那也说明新的生产关系来了得准备好迎接生产力的解放了，如果没有好好跟上或利用好这次机会可能真的会被甩下。 ","date":"2023-04-04","objectID":"/alt-ai/:2:0","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"尾巴 大学学了三年，发现大家都很难找到工作，内卷成为各个行业的常态，很难说不对未来感到迷茫。 不论如何，我们不应该再去重复那些 ChatGPT 或者是其他 AI 能够完成的工作。 ","date":"2023-04-04","objectID":"/alt-ai/:3:0","tags":null,"title":"AI 是怎么解放生产力的","uri":"/alt-ai/"},{"categories":null,"content":"人人都有保护自己和追求幸福的权力 ","date":"2023-01-22","objectID":"/fly-to-2023/:0:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"生活 关键词：一坨💩 为什么说 2022 年我的生活是一坨屎呢？因为在这一年里看见了太多奇葩事情 女朋友因为被不能表示健康状态的健康码限制出行，导致两个月不能见面 两次一个月的封校 和喜欢甩锅的人一起合作 不科学防疫 糟糕的就业环境 牙齿又坏了 如果不是疫情来的这么突然和持久，我也不会这么早接受了社会是一坨屎，大学只不过是屎的同心圆。虽然是一坨屎，但是为了生活只能被迫的接受这 PUA，成为有钱人才是最重要的。 在这一年里看见了许多荒谬但又真正存在的事情： 俄乌战争 美国继续做世界的搅屎滚 乌鲁木齐火灾 他的软肋就是他的儿子 非必要不 xxx …… 熟悉的世界已经过去，去拥抱改变吧，历史总是螺旋上升的。 ","date":"2023-01-22","objectID":"/fly-to-2023/:1:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"学习 关键词：少壮不努力，老大徒伤悲 到了大学才知道有个好学历是真他妈的香，作为在求职链底端的专科如果想要在求职市场上有相同的待遇就需要肝了。 PS.福建教育厅的人可能不懂教育，但是太懂政治了！一群不懂社会需求/专业基础知识的人来指定政策就是能看到理工科考大学语文，计算机不学数据结构、算法、数据库、计算机网络。呜呼，荒谬！ ","date":"2023-01-22","objectID":"/fly-to-2023/:2:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"职业规划 关键词：Web 前端、鄙视链 我不清楚为什么会有后端程序员看不起前端程序员： 后端没解决跨域问前端为什么不做代理 前端就是做个组件的复制粘贴 要不是我没时间，我也可以做出前端的页面 一个破网页需要担心什么性能 网络问题是你前端的代码 Bug 没有任何分析就判断这是你的问题，为自己辩解那就是你高傲 我不理解这样的原因是什么，但我不想接受这样的 PUA，在学校里面就能遇到这样的情况，我没有理由不相信到了工作上也会遇到这样的情况。所以我决定以后做后端了，做一个和前端好好沟通让前端舒服的调接口的后端程序员（Java 那一套真的是太繁琐了，充斥着各种黑魔法） 虽然不知道为啥在国内啥技术都注重 Web（因为互联网公司发展的好？）虽然不太理解，但是能赚钱当然还是学 Web 的啊。 现在的互联网大厂的招聘力度大幅减小、裁员力度增加，计算机专业的好日子也到头了。可恶啊，我还没享受到互联网寒夜的红利就要被迫『内卷』了嘛。 ","date":"2023-01-22","objectID":"/fly-to-2023/:3:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"展望未来 生活就是能过一天是一天，奋斗逼是没有前途的。 ","date":"2023-01-22","objectID":"/fly-to-2023/:4:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"尾巴 2022 是如此的魔幻但也还是活到了 2023，不说自己变聪明了但绝对的更懂的生活的规律了，新的一年就希望自己的三观能更加的稳定和强大。 过去的一年也有很多值得高兴的事情就不一一列举了，Love \u0026 Peace。 ","date":"2023-01-22","objectID":"/fly-to-2023/:5:0","tags":null,"title":"2022年度关键词","uri":"/fly-to-2023/"},{"categories":null,"content":"之前看 CS61B 的时候看到里面的第一个例子就是用 JUnit 来作为检查数据结构和算法有没有写错的验证程序，后来学了 Java 之后才知道 JUnit 是一个单元测试包，专门用来测试一些函数是否能得到预期的结果。但在学习 Web 前端的时候就一直没有看到过有教程或者是学习路线中有提到前端开发的单元测试要怎么写。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:0","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"为什么不能没有单元测试 单元测试的目的很简单，就是为了验证代码能不能按照编写的预期工作的，如果在写完一个函数就进行单元测试并通过就能更快的将问题排查出来，而不是等到项目运行的时候才去排错。 插一句不太相关的话，在平时的项目用 TypeScript 来替换 JavaScript 的一个很大原因就是希望将一些错误留在编译期间而不是项目运行时。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:1","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"为什么会是 Vitest 很简单，因为 vitest 的核心成员有 vue 和 vite 的核心成员，所以 vite 项目里集成 vitest 只要改动 vite.config.ts 里的几行配置就可以啦。 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:2","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"准备工作 安装依赖 要在 vue 项目中加入 vitest 先要下载依赖： pnpm add @vue/test-utils jsdom vitest -D @vue/test-utils 是官方的测试工具库，jsdom 是拿去模拟 DOM 的，vitest 作为单元测试。 修改配置文件 只需要将 defineConfig 换成从 vitest/config 引入，然后再添加一个 test 属性指定测试的 DOM 环境即可。 /* 将 vite 的 defineConfig 换成 vitest/config 的 defineConfig */ import { defineConfig } from 'vitest/config' // https://vitejs.dev/config/ export default defineConfig({ // 其他配置 test: { environment: 'jsdom', // 指定虚拟 DOM 环境 }, }) 要测试什么？ 在测试之前我们需要知道希望某个组件预期会有什么效果。我准备的测试需要检查以下内容 Hello 组件根据 DOM 渲染出一对 \u003ch1\u003e\u003c/h1\u003e 标签 标签内部是否有文本 Hello vue Hello 组件 \u003cscript lang='ts' setup\u003e \u003cscript lang='ts' setup\u003e const props = withDefaults(defineProps\u003c{ msg: string }\u003e(), { msg: 'Hello Vue', }) \u003c/script\u003e \u003ctemplate\u003e \u003ch1\u003e{{ msg }}\u003c/h1\u003e \u003c/template\u003e ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:3","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"开始测试！ 创建测试文件 现创建一个 __test__ 的文件夹专门用于存放测试文件，然后在此文件夹里创建一个 Hello.test.ts 的测试文件。 创建一个测试 可以通过引入 vitest 里的 descript 函数来创建一个测试组，它接收一个字符串作为测试组的名字和一个函数进行测试。 describe('Hello.vue', () =\u003e { // 需要测试的代码 }) 在 descript 的回调函数中我们可以使用 vitest 的 test 来创建一个测试函数，同样的它也接受一个字符串作为测试的名字和一个回调函数。 describe('Hello.vue', () =\u003e { test('mount component', () =\u003e { // 需要测试的代码 }) }) 但在开始测试之前我们必须拿到需要测试的组件，我们可以通过 @vue/test-utils 里的 mount 函数做到这一点，它接收一个 Vue 组件和一些可选配置 /** * 创建一个 wrapper 包含需要渲染的组件 * @param Component 需要测试的组件 * @param options 可选项配置 */ function mount(Component, options?: MountingOptions): VueWrapper interface MountingOptions\u003cProps, Data = {}\u003e { attachTo?: HTMLElement | string attrs?: Record\u003cstring, unknown\u003e data?: () =\u003e {} extends Data ? any : Data extends object ? Partial\u003cData\u003e : any props?: (RawProps \u0026 Props) | ({} extends Props ? null : never) slots?: { [key: string]: Slot } \u0026 { default?: Slot } global?: GlobalMountOptions shallow?: boolean } 我们可以在 test 中拿到这个需要的组件 describe('Hello.vue', () =\u003e {describe('Hello.vue', () =\u003e { test('mount component', async () =\u003e { // 通过 mount 拿到一个包含 Hello 组件的 wrapper const wrapper = mount(Hello, { // 传入 Hello 组件的 props props: { msg: 'Hello Vitest', }, }) }) }) 验证程序 到目前为止我们已经创建好测试文件和拿到需要渲染的组件，接下来就是验证组件有没有按我们预期进行渲染。 现在就可以使用 vitest 中的 except 来验证组件的某些部分是否和我们预期的相同。现在 Hello 组件应该是只会显示标题 1 且文本为 Hello Vitest，所以我们可以这样做： const expectMsg = 'Hello Vitest' // wrapper.find() 来查找组件中的一个 HTML 标签 // wrapper.text() 返回一个元素的文本 expect(wrapper.find('h1').text()).toContain(msg) 到这一步我们的测试文件就写完啦，可以在终端里运行 pnpm run test 这样就完成了在 vue 中集成 vitest。 完整测试程序 import { describe, expect, test } from 'vitest' import { mount } from '@vue/test-utils' import Hello from '@/components/Hello.vue' describe('Hello.vue', () =\u003e { test('mount component', async () =\u003e { const msg = 'Hello Vue \u0026 Vitest' const wrapper = mount(Hello, { props: { msg: 'Hello Vue \u0026 Vitest', }, }) expect(wrapper.find('h1').text()).toContain(msg) }) }) ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:4","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"Useful Link Vitest | 由 Vite 提供支持的极速单元测试框架 Home | Vue Test Utils (vuejs.org) 测试代码 ","date":"2023-01-17","objectID":"/vue-vitest-test/:0:5","tags":null,"title":"Vue 集成 Vitest","uri":"/vue-vitest-test/"},{"categories":null,"content":"2022 年 12 月 22 号我不幸感染了 COVID-19，根据最新的中文叫法应该是「新冠感染」，不过我不想玩那么低级的文字游戏，所以就用 COVID-19 来称呼。 鼓励和推荐能接种疫苗的人群都应该去接种疫苗，接种疫苗是防护COVID-19 和降低对身体伤害最简单的方式 ","date":"2022-12-27","objectID":"/covid-19-review/:0:0","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"可能被感染的地方 在被感染的前一天去了超市 家人传染 房东传染 但不管是那种方式，反正最后是感染了哈哈 ","date":"2022-12-27","objectID":"/covid-19-review/:0:1","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"感染后 每个人感染之后的症状都不太一样包括但不限于：头疼、喉咙痛、咳嗽、咳痰、无力、全身发冷、嗜睡、出汗，但是可以确定是 COVID-19 绝对不是大号感冒。在感染期间我是只吃了布洛芬，家人也有吃对乙酰氨基酚片的，作用都是一样的，一定要大量的饮水，因为发烧出汗会带走体内的水分。有不舒服一定要及时用药和就医，不要小看 COVID-19 了，哪怕是感染之后康复也要戴好口罩避免重复感染 第一天 第一天起床就是明显的感觉头疼和没力气，但这个时候还没感觉是感染了，因为出门也是一直都戴着口罩的，就以为是普通的着凉然后头疼还没太当回事不过这前两年回来也会感冒或者头晕几天，然后下午睡了一觉和我妈也是同样的症状，这个时候才基本确定自己是感染了。 晚饭前就吃了两粒布洛芬，吃完晚饭后就精神多了但是头还是有点晕。睡觉醒来还是会一身的汗，在保证自己不冷的情况下穿宽松一些的衣服是比较利于人体散热的 关键词：头晕、无力、出汗、浑身痛 第二天 第二天的头疼就好很多了，早上就吃了一粒也是感染期间最后一粒布洛芬，在以为自己好的差不多的时候，我开始咳嗽了！刚开始这个咳嗽是真的难受，每次都是连着咳三四下，虽然咳的幅度不大但是也已经是我咳嗽过最严重的一次了。 伴随着咳嗽来的还有喉咙痛，我是在难受的吃了几个草珊瑚含片，确实有缓解喉咙痛的作用但不持久，我算是比较幸运的并不是「刀片嗓」，而且都是在咽口水的才会疼，吃饭的时候不疼😂 关键词：头晕、出汗、咳嗽、喉咙痛 第三天 这一天是感染以来最后一天因为身体不舒服而睡到十一点起床，继续咳嗽、咳痰和喉咙痛，但头疼和发烧的症状是都消失了，算是进入恢复阶段了。 关键词：咳嗽、喉咙痛 第四/五天 这两个天就基本没有感觉自己身体有哪里不舒服了，还是依旧居家不给他人带麻烦，咳嗽感觉是没有那么快好的了，不好人痊愈了也还是会咳嗽。 关键词：咳嗽、恢复 ","date":"2022-12-27","objectID":"/covid-19-review/:0:2","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"三个月后打疫苗 这次感染也不是特别意外，总有感染的一天只是时间早晚的问题，如果一直没有感染那当然是最好的啦，很倒霉是在这次感染是在第三针疫苗打完一年后感染的，这就意味着疫苗对我的防护力已经是大幅度降低。本来还想去接种第四针疫苗的，既然已经感染了那就等三个月后再去了～ ","date":"2022-12-27","objectID":"/covid-19-review/:0:3","tags":null,"title":"Covid 19 Review","uri":"/covid-19-review/"},{"categories":null,"content":"配置的烦恼 每次用个新的工具链都要先看一下怎么换到国内源，要不然那个下载速度实在是太感人了，所以就打算收集一下 Web 前后端开发需要换源的工具链。 在这也感谢各机构备份镜像源，如果没有你们也就不会有这篇记录。 ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:1","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"系统设置 Homebrew Homebrew 是 macOS 下的一个包管理工具，可以很方便的去安装、管理各种开发环境和软件，如果你用的也是 macOS 作为开发平台 homebrew一定不可错过的一个好工具。 查看当前源： cd \"$(brew --repo)\" \u0026\u0026 git remote -v 替换为清华源： git -C \"$(brew --repo)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/brew.git git -C \"$(brew --repo homebrew/core)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-core.git git -C \"$(brew --repo homebrew/cask)\" remote set-url origin https://mirrors.tuna.tsinghua.edu.cn/git/homebrew/homebrew-cask.git echo 'export HOMEBREW_BOTTLE_DOMAIN=https://mirrors.tuna.tsinghua.edu.cn/homebrew-bottles' \u003e\u003e ~/.zshrc source .zshrc ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:2","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"前端 Node 正式因为 Node 的出现前端才越来越组件化、工程化，Node.js 的发展也证明它不仅可以在前端发光发热，在后端领域也是有着不少合适的领域。 npm、yarn、pnpm 都是前端的包管理工具，个人更偏爱 pnpm 一点但是 yarn 在键盘上的位置更好按哈哈哈哈 npm # 查看当前源 npm get registry # 设置 npm 镜像源为淘宝镜像 npm config set registry https://registry.npm.taobao.org/ yarn # 查看当前源 yarn get registry # 设置 yarn 镜像源为淘宝镜像 yarn config set registry https://registry.npm.taobao.org/ pnpm # 查看当前源 pnpm get registry # 设置 pnpm 镜像源为淘宝镜像 pnpm config set registry https://registry.npm.taobao.org/ ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:3","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":"Python 说到编程语言怎么能少的了 Python 呢，虽然纯 Python 的岗位不多但是 Python 上手真的是非常友好了。Python 也有着超多的第三方库，我完成的第一个小游戏飞机大涨就是用 Python 和 PyGame 写出来的。 pip 查看当前源： pip config list 替换为清华源： pip config set global.index-url https://pypi.tuna.tsinghua.edu.cn/simple ","date":"2022-11-30","objectID":"/toolchain-source-config/:0:4","tags":null,"title":"Web 工具链换源","uri":"/toolchain-source-config/"},{"categories":null,"content":" 如何入手一个开源项目 克隆到本地 安装依赖 pnpm yarn npm 看 package.json 主要看 script 和 dependencies 部分 从 App 组件入手，逐级往下看 ","date":"2022-10-20","objectID":"/to-use-opensource/:0:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"为什么要找开源项目 很多人在学完基础想要找项目的时候就不知道怎么找，有些是因为之前的视频看的都是培训机构的视频，如果当前这个培训机构的项目实战视频又有点老了或者是一些后端接口不能用的情况，当然这不是他们的问题，机构也需要为自己的发展做打算，一般能发出来作为视频教程的都是已经被机构内部淘汰出来的项目其他的基础教程也是同理。所以想把新技术都用上就只有去实现自己的一个 idea 或者是在 Github 上找到适合自己的项目。 我那时候就是这样的，看到机构的项目实战视频都有点老了，就自己去 Github 上找开源项目，找啊找终于是找到是纯前端的项目了。可就是咋样的都看不懂代码，于是我就从 components 文件夹开始抄，package.json 文件我就直接复制然后下载依赖，做完发现不对啊，我还是看不懂啊，怎么会这样，明明是把项目都抄了一遍，效果是出来了，但我咋还是不明白呢？ 能写下这篇文章就说明我已经是踩了很多坑之后，才明白的要怎么样从 0 开始入手一个前端的开源项目。这就来分享一下我在自学前端的时候遇到的坑～ ","date":"2022-10-20","objectID":"/to-use-opensource/:1:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"分析过程 一般在 Github 上 star 数比较多的项目都会有一个比较详细的 README 文档，一般包括以下几点： 项目介绍 项目特点 在本地如何开发 项目完成/没完成哪些功能 开源协议 这篇文章着重介绍如何在本地开发。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"在本地启动项目 首先入手项目的第一步肯定是想把项目下载到本地，一般都是 先把项目克隆到本地 git clone xxx example-project 然后紧接着就是安装依赖 cd example-project npm/yarn/pnpm install 最后再根据 package.json 里的命令把项目在本地给跑起来 pnpm serve/start/dev 这样就跑通了一个项目，安装依赖方面多说一句有时候用 pnpm 安装好的依赖可能跑不通，就换 yarn/npm 试一下。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:1","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"目录分析 在本地开发最重要的就是要看懂那些代码都做了什么，一般的前端项目都会有一个 App 组件在 Vue 项目里是 App.vue，React 则是 App.txs，入口文件则都是 main.ts。 在这我的建议是从上到下去分析目录，先看 package.json 了解一下项目大概都用了哪些依赖以及启动/打包项目的命令是什么，然后再去 main.ts 里看都引入了哪些组件和工具函数，最后就一步步的从 App 开始往下看。 有和后端联调的项目就去看看它都发了哪些请求、是怎么封装 axios 请求的，也可以用 postman/apifox 这样的工具去测试一下一些接口是返回什么数据的。 这个时候千万不要着急去动手写，看别人怎么写的代码是非常重要的，花个三五天甚至一周时间看代码看一遍都无妨。优质一点的项目代码量基本都不小，直接上手开始模仿人家的代码可能会直接晕掉。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:2","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"开始动手 在做了以上两步再结合项目介绍，对项目也已经有了一个更加清楚的认知了，这个时候就可以根据自己的需求是在原项目上添加一些功能还是说自己在学习的过程中发现了一些 bug 也可以试着去 fork 这个仓库去提 issues、去解决它。 在学习的过程中，最忌讳直接去抄代码的，这样做一遍下来可以说是毫无效果的，先思考这个页面做到这样的效果的，自己试试看能不能做一个最小实现的 demo。这样渐进的去学习做一个项目才是能收获到最多的。 很多东西是在看项目的时候是不知道的，这是很正常的。遇到没有用过的第三方包就去搜：npm + 包名，一些组件不知道怎么用就去查文档，英文文档看不懂？那就一边开翻译一边原文对着看啦。等自己的项目做完了好好的写一个 README 就算是完成了这个项目。 ","date":"2022-10-20","objectID":"/to-use-opensource/:2:3","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"总结 软件开发是个正向激励很快的工作，我的水平很次，但我很享受看到自己写的项目成果呈现在眼中去向朋友介绍我做了一个什么什么的网站，实现了什么什么样的功能，正是这些激励着我继续去做这件事。 ","date":"2022-10-20","objectID":"/to-use-opensource/:3:0","tags":null,"title":"如何入手一个前端开源项目","uri":"/to-use-opensource/"},{"categories":null,"content":"个人知识库搭建 为什么要搭建个人知识库 方便复习 方便分享 搭建知识库的需求 支持 Markdown 语法 云同步 好看 思维导图 流程图 没有广告 怎么搭建 写作软件 个人博客 总结 下学期就专升本考试了，恰好一直想整理一下自己的笔记，就想趁着这次机会学的知识都构建成一个知识库。 ","date":"2022-10-05","objectID":"/your-mind-palace/:1:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"为什么要搭建个人知识库 在没有搭建知识库学习的时候笔记文件总是这里一个哪里一个，检索麻烦不说还经常忘记在哪里，当我想复习的时候根本找不到笔记在哪。虽然有写博客的习惯，但写博客更应该是解决/分享某一个点而不是作为输出笔记的的地方，因为记录的都是笔记，能方便的发给同学看也是一点。基于以上两点我迫切需要一个软件来整理我的笔记！！！ ","date":"2022-10-05","objectID":"/your-mind-palace/:2:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"我的需求 在我眼里一个好的知识库需要具备这些条件： 支持 Markdown 语法 有思维导图 写作大纲 全平台云同步 无广告 好看 我愿意花钱在好用的软件上面。 ","date":"2022-10-05","objectID":"/your-mind-palace/:3:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"怎么搭建知识库 我的手机是 iPhone，电脑是 Mac，在这两个设备之间有个 iCloud 能很好的进行数据同步，但是我最常用的笔记软件 Typora 并不支持云同步，哪怕是把它写的文章都放到了 iCloud 中但是在 iPhone 上我也一直没有找到一个好用的 Markdown 编辑器，Bear 和 Ulysess 的定位也是写作软件作为知识管理软件也是费劲。其实我一直都知道 Notion 这个软件，但是由于其复杂的操作和云同步不是特别的稳定，所以 Notion 也被 pass 了。 恰好看到了语雀恰好这些功能语雀都支持，而且语雀还有 Web 版。体验了一段时间最重要的云同步也没有出现啥问题，虽然在语雀里写 Markdown 没有 Typora 那么爽但也无伤大雅，可以在本地写好在复制黏贴嘛。 虽然语雀也被官方定义为“小记”软件，本着一个软件只做一件事的想法，在使用语雀的过程中我只使用其知识库的功能。 ","date":"2022-10-05","objectID":"/your-mind-palace/:4:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"总结 虽然语雀可以解决的不只是知识库搭建的问题，但知识库最重要的是知识而不是用什么工具，工具只是方便了我们管理知识，要是没有语雀我用 txt 文本也能记录，就是没有那么方便一点而已，最重要的还是自己去学习啊。 ","date":"2022-10-05","objectID":"/your-mind-palace/:5:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"尾巴 语雀的出现让我对所有本地写作软件的要求高了一个层级，当一个软件的 Web 端都能有不错的用户体验之后为什么还需要一个本地 App 呢？只要同步功能做的足够的好在 Web 上写好的文档也能做到不丢失文档。能想象到未来会有越来越多的软件在 Web 端能做的越来越好，Vue 和 React 这类前端框架让 Web 端开发方便了太多。在 2022 年的今天，所有 Web 端体验做的不好的企业，只能说是对 Web 端一点都不重视，更不用说在手机上浏览某些网页的时候会有像“狗皮膏药”版的下载 App 的提示，真的是 Web 端体验不好吗？那倒未必是，很多人的工作用一个现代桌面浏览器就能解决。 ","date":"2022-10-05","objectID":"/your-mind-palace/:6:0","tags":null,"title":"聊聊我是如何搭建个人知识库的","uri":"/your-mind-palace/"},{"categories":null,"content":"只要掌握编程语言中某一种某种思想，其实对于掌握其他的编程语言就已经打下了十分牢固的基础。但配置编程语言环境不是啊～ 幸运的是我学的第一门编程语言是 C 语言，第一次使用的 IDE 是 Xcode，安装完完整的 Xcode 之后会得到：GCC、Git 等各种编程需要用到的环境，让我在写 C 语言的时候十分的舒服。在我学习 Python 的时候，恰好电脑里又有 Python2 的环境，这也让我省去了配置环境的麻烦。 直到我开始学习《算法 4》，书中的使用到的库并不是 Java 的标准库而是作者根据书的需求写的，光是配置那个 Java 的环境变量就折腾了好久；然后又是 Pyhon 之间的版本差异又折腾了老半天。在使用 VSCode 配置 Go 编程环境的时候又搞了一小会，最后是在知乎上找到解决 VSCode 安装 Go 插件失败的问题才解决的。 最近开始学习 Ruby，系统自带的 Ruby 是 2.x.x 版本，而且系统自带的 gem 每次执行 gem install 就显示“权限不够”，意思就是要用 sudo gem install xxx 才行，而一条要用 sudo 就意味着它的不凡，可能是会对电脑造成不可逆的“伤害”（虽然我已经使用 sudo gem install xxx 安装了一个包），最后看了 Ruby China 上的如何快速正确的安装 Ruby, Rails 运行环境就解决了。 虽然不是对每门编程语言都很熟悉，但是电脑里还是需要有其的运行环境万一需要用到了嘛。在安装编程语言环境上 macOS 秒杀 Windows 18 条街，有 homebrew 真的少走了很多坑，如果是 Windows 估计我还在搜索引擎上找资料。 PS. 还是运行 JavaScript 方便，现代浏览器就可以～ ","date":"2022-09-13","objectID":"/aboutlearnnewprogramminglang/:0:0","tags":null,"title":"关于新学一门编程语言的痛","uri":"/aboutlearnnewprogramminglang/"},{"categories":null,"content":" 0基础想自学编程，不知道学前端还是后端还是其他，也不知道学哪种编程语言? 未来几年最有前景的三门编程语言是什么？ 大学生想学编程，想了解下 Python，C 语言和 Java？ 自学计算机该先从什么开始？如何自学？入门推荐学什么语言？ 在知乎看了一些计算机方面相关的内容之后，就能很容易的看到这些关于选择学什么编程语言好的话题/提问。刚开始接触编程的时候我也遇到过这样的问题，刚好最近开始学习 Ruby 借这个机会来说一下我对如何选择编程语言的看法。 ","date":"2022-08-31","objectID":"/first-language/:0:0","tags":null,"title":"第一门编程语言学什么好？","uri":"/first-language/"},{"categories":null,"content":"第一门编程语言要学 C/C++ 吗？ 在知乎问”如何选择编程语言“下经常都能看到： 建议先学 C/C++，之后再去学别的编程语言就会更轻松 事实其实也就是这样的，但学完 Python 再去学其他编程语言也会变得更轻松，只要能够了解到编程的本质是通过函数来操作数据，无论第一门编程语言学的是什么再去学别的编程语言都会轻松一些。 第一门编程语言也并非要学 C 语言或者 C++，学任何一门现在流行的编程语言都是可以的（Java、C、C++、JavaScript、TypeScript、Python 等等）。 ","date":"2022-08-31","objectID":"/first-language/:0:1","tags":null,"title":"第一门编程语言学什么好？","uri":"/first-language/"},{"categories":null,"content":"弱类型 VS. 强类型 动态的语言的代表我想选择 Python 来举例，Python 的变量声明很符合直觉。 x = 1 x = \"Hello World\" OK，这样就声明好了两个变量，把一个数字或者一个其他的什么东西让 x 这个字母来代替，我们可以用 x 去代表任何一个东西它只是一个代号。 其实上面的代码用 Java 来描述也不会更复杂： int x = 1; String x = \"Hello World\"; // ooops something eror! 发生变化的只有在声明变量的时候多了一个 int 或者是 String 这样的东西，其实也不难理解就是为变量多加了一个类型而已。当也正是因为类型让这段代码出错了。 Python 是动态类型的编程语言，变量的名称是一个代号，我们通过这个代号去让变量做些什么事情，这个过程我们不在乎代号指代的东西变成了其他的什么东西。 Java 恰恰相反，如果一个代号已经被别人声明使用过了，我们只能让它去代表差不多的东西（继承），比如一个 long 类型的变量可以存储数字，我们可以让他去代表一个 int 类型的变量这是可以的，但让他去代表一个 String 类型的的就会报错。 ","date":"2022-08-31","objectID":"/first-language/:0:2","tags":null,"title":"第一门编程语言学什么好？","uri":"/first-language/"},{"categories":null,"content":"动态语言 VS. 静态类型 世界上最火热的编程语言 JavaScript 就是一门典型的弱类型语言，因为变量的类型可以根据需要来变化： a = 1 // typeof a = number a = \"Hello World\" // typeof a = string 常说的弱类型语言的智能提示功能比较差很大一部分原因是在于不知道那段代码会修改了某个变量的类型，极大的影响了开发工具提示功能。 TypeScript 和 JavaScript 就是一个对立面，如果一个类型是 number 的变量再给他赋一个 string 类型的值编辑器就会马上报错，告诉你这样是不行的。 a = 1 // typeof a = number a = \"Hello World\" // ooops error 严格的类型匹配也让开发工具的智能提示变得正常起来，再也不需要在一堆没用的方法里找到自己想要的了。 对我而已，我更喜欢 TypeScript 这样的静态强类型语言，我不介意在每次写代码的时候都写一下类型让我获得更好的开发体验。我用 TypeScript 单纯就是为了获得到更好的代码提示得到更好的开发体验。 ","date":"2022-08-31","objectID":"/first-language/:0:3","tags":null,"title":"第一门编程语言学什么好？","uri":"/first-language/"},{"categories":null,"content":"一些小感悟 编程语言里没有银色子弹，需要找工作就学习市场需求量大的编程语言，对某个领域感兴趣就学习“领域专用语言”（DSL，Domain Specific Language），比如使用 Vue 也需要去学习一下 Vue 的模板语法。 在今天这个时代，选择技术路线是一件关乎升生机的事情，是不存粹也不能存粹的一件事情。我现在的选择就在在找工作的时候找需求量大的，私下使用自己欣赏的。 ","date":"2022-08-31","objectID":"/first-language/:0:4","tags":null,"title":"第一门编程语言学什么好？","uri":"/first-language/"},{"categories":null,"content":"const 是为了解决什么问题？ 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区的大小不再合适的时，很容易对其进行调整。另一方面，也随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以使用关键字 const 对变量的类加以限定： const int BUFSIZE = 512; 以上便是 const 在《C++ Primer》中的解释。 第一次看书的时候觉得 const 不就是定义一个常量用的东西，没啥好关注的。直到写出 const int x = 10; 和 int const x = 10 一时竟不知道其区别是什么，于是决定再翻翻《C++ Primer》看一下 const 的使用方法，也解决一下心中的困惑。（还顺便发现 LoveIt 主题一个 bug：代码块中不能识别 C/C++ 代码） ","date":"2022-07-31","objectID":"/aboutconst/:1:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的引用 可以把引用绑定到 const 对象上，一般称之为对常量的引用（reference to const)，和普通引用唯一不同的是，对常量的引用不能改变它所绑定的对象： const int obj = 1024; const int \u0026r1 = obj; // 正确：引用及其对象都是常量 r1 = 512; // 错误：常量引用不可改变其绑定的对象 int \u0026r2 = obj; // 错误：试图让一个非常量引用指向一个常量对象 int i = 1024; const int \u0026r3 = i; // 正确：对 const 的引用可以引用一个非 const 的对象 r3 = 0; // 错误：r3 是一个常量引用 ","date":"2022-07-31","objectID":"/aboutconst/:2:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 和指针 与引用一样，也可以领指针指向常量对象，类似于对常量的引用，**指向常量的指针（pointer to const）**不能用于改变其所指向对象的值： const double pi = 3.14; double *p2Pi = \u0026pi; // 错误：p2Pi 是一个普通指针 const double *cp2Pi = \u0026pi; // 正确：cp2Pi 可以指向一个 double 常量 *cp2Pi = 3.1415; // 错误：指向常量的指针不能用于改变其所指向对象的值 ","date":"2022-07-31","objectID":"/aboutconst/:3:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 指针 以上都是些开胃小菜，下面的内容会对 const 有了一个新的认识。 指针是一个对象，所以**常量指针（const pointer）**必须初始化，而且一旦初始化指针指向的地址就不可以改变了。把 * 放在 const 关键字之前就说明该指针是一个常量指针。 double pi = 3.14; const double *const p2Pi = \u0026pi; // p2Pi 是一个指向常量对象的常量指针 int num = 1024; int *const currNum = \u0026num; // currNum 将一直指向 num 这样的书写方式也隐含着：不变的指针本地的值而非指向的那个值。 想要弄清楚这些含义最好的方式就是从从右向左看。此例中：离 currNum 最近的符号是 const，意味着这是一个常量对象，下一个符号是 *，意思是 currNum 是一个常量的指针，最后的类型部分确定了常量指针指向对象的类型。类似的 p2Pi 就可以解读为一个指向常量的指针常量。 指针本身是一个常量并不意味着不能通过指针修改对象的值，能否这样做取决于指向对象的类型。 ","date":"2022-07-31","objectID":"/aboutconst/:3:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的位置 指针本身使用过对象，它可以指向另外一个对象。所以，指针本身是不是常量以及指针所指向的是不是一个常量就是两个独立的问题。用名词**顶层 const（top-level const）表示指针本身是一个常量，而用底层 const（low-level const）**表示指针指向的对象是一个常量。 double pi = 3.14; const double d = 2.0; // 不能修改 d 的值，这是一个顶级 const const double *p1 = \u0026pi; double *const p2 = \u0026pi; const double *p3 = \u0026pi; *p1 = 3.1415; // 错误：p1 是指向常量的指针（底层 const） p2 = \u0026d; // 错误：p2 是指针常量，不能修改指向的对象（顶层 const） *p3 = 10; // 错误：不允许改变 *p3，p3 是一个指向常量的指针 const double *const p4 = p2; // 靠右的 const 是顶层 const，靠左的是 底层 const const double \u0026r = pi; // 用于声明应用的 const 都是底层 const 如果是在变量中使用了顶/低层 const： const int x = 10; int const x = 10; 按照前面的定义可以说这两个声明的意思是一样的，定义了一个变量名为 x，值等于 10 的一个常量。两种方式都可以声明一个常量，我还是习惯于些 const int x = 10。 ","date":"2022-07-31","objectID":"/aboutconst/:3:2","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"函数中的 const 当形参是 const 时，如前面所述，顶层 const 作用于对象本身： const double pi = 3.14; double num = pi; // 正确：拷贝 pi 时忽略其顶层 const double *const p = \u0026num; // 错误：const 是顶层的，不能给 p 复制 *p = 0; // 正确：通过 p 改变 num 是合法的: =\u003e num = 0 和其他初始化过程一样，当实参初始化形参时会忽略其顶层 const。换句话说，当形参顶层有 const 时，传给它的值可以是常量也可以是非常量。 void foo(const int \u0026num); void foo(int \u0026num); // 错误：因为前一个函数顶层参数被忽略了，所以这两个函数的参数列表是一样的 ","date":"2022-07-31","objectID":"/aboutconst/:4:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"class 中的 const 函数 假设我们现在有这样一个 class： #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() { return stk.size(); } private: std::vector\u003cstring\u003e stk; }; 还有这样一个函数： int getStackSize(const Stack *stk) { return stk-\u003esize(); } 因为 stk 是一个 const reference 参数，因此在调用 getStackSize() 的时候应保证其不会修改 stk 的值，但是在 stk 上调用的每一个方法都有可能会影响 stk 的值，我们必须在成员函数上标注 const 来告诉编译器：Hi，编译器，在 Stack 对象调用 size() 方法的时候不会修改其对象的值: #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() const { // const 修饰符紧接在函数参数列表之后 return stk.size(); } private: std::vector\u003cstring\u003e stk; }; ","date":"2022-07-31","objectID":"/aboutconst/:4:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"从前后端分离开发说起 都说前后端开发要分离，而前后端分离的重点就是前后端独立可运行，那在后端接口没有返回数据的情况下来完成前端数据的获取呢？答案就是使用 Mock 数据来模拟预先与后端约定好的接口数据，来作为开发时的测试数据。 ","date":"2022-07-22","objectID":"/mockdata/:0:1","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"Mock 数据 什么是 Mock 数据 Mock.js 是一款模拟数据生成器，可以生成模拟数据来让前端开发独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据模版生产模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模版生成模拟数据 使用 Mock 数据 安装 yarn add mockjs 使用 import Mock from 'mockjs' const Dashboard = Mock.mock({ 'sales|8': [ { 'name|+1': 2008, 'Clothes|200-500': 1, 'Food|180-400': 1, 'Electronics|300-550': 1, }, ], cpu: { 'usage|50-600': 1, space: 825, 'cpu|40-90': 1, 'data|20': [ { 'cpu|20-80': 1, }, ], }, ... }) 这个项目所有的数据都是由 Mock.js 生成的，在 Umi 项目中，/mock 文件夹里的所有文件都被视为 Mock 数据文件。 在 /mock 里的文件，最后都有一行 module.exports = { } /mock/dashboard.js module.exports = { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) }, } 这段代码的意思是生成了一个 GET 方法，地址为 localhost:port/APIPrefix/dashboard 的后端接口，使用 Postman 等工具也可以测试的出来返回结果。 同样的也可以使用 ESM 来导出： export default { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) } } Mock 数据生成规则详情见 Mock.js wiki ","date":"2022-07-22","objectID":"/mockdata/:0:2","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"为什么要使用 TypeScript？ JS（JavaScript）是一门功能强大的语言，但是作为一门动态类型语言有时候简直是在浪费 IDE 强大的补全功能，就因为它是弱类型的语言，IDE 不能准确的推断出对象的类型，从而进行准确的提示。这一点对 VSCode 这种文本编辑器影响愈大。 TS（TypeScript）作为 JS 的一个超集，就和它的名字一样，为 JS 添加了 Type。作为一门静态语言，毫无疑问对 IDE 的语法补全有出色的帮助。别的优点不提，在 IDE 中的补全更强就是使用 TS 的一大理由，而且类型本身就是一种注释，哪怕需要添加更多的代码。 ","date":"2022-06-28","objectID":"/reactwithts/:1:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"在 React 中使用 TS 新建一个 React app 最简单的方式当然是使用 CRA 的 TS 模版了。 npx create-react-app my-ts-app --template typescript 打开项目，目录结构为： ├── README.md ├── node_modules ├── package-lock.json ├── package.json ├── public ├── src └── tsconfig.json 打开 /src 会发现 原来的 .jsx 文件的都变成了 .tsx。 ","date":"2022-06-28","objectID":"/reactwithts/:2:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"创建一个 TS 组件 import { useState, useEffect } from \"react\"; // Type with props export interface HelloProps { name: string; enthusiasmLevel?: number; } const Hello = ({ name, enthusiasmLevel = 1 }: HelloProps) =\u003e { const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } // Hooks with TS // 将 message 的类型设置为 string const [message, setMessage] = useState\u003cstring\u003e('') useEffect(() =\u003e { setMessage(`Hello ${name}` + getExclamationMarks(enthusiasmLevel)) }, [enthusiasmLevel, name]) return ( \u003cdiv\u003e \u003ch1\u003e{ message }\u003c/h1\u003e \u003c/div\u003e ); }; export default Hello; 注意到我们定义了一个 HelloProps 类型，它指定了这个组件需要用到的属性。在接受参数的时候我们为参数加上类型 HelloProps，一旦定义了类型，那么父组件就一定需要传递类型中的属性给子组件，否则将会报错。这样我们在 Hello 组件里接受到的参数就都是有类型的了。 同样的我们也可以选用类式组件 // src/components/Hi.tsx // 只是组件类型和 Hello.tsx 不同，其他都是一样的 import React from 'react' export interface HiProps { name: string enthusiasmLevel?: number } // React.Component\u003cHiProps, object\u003e 相当于 React 的泛型 // 这里的 HiProps 是 this.props 类型 class Hi extends React.Component\u003cHiProps, object\u003e { render() { const { name, enthusiasmLevel = 1 } = this.props if (enthusiasmLevel \u003c= 0) { throw new Error('You could be a little more enthusiastic. :D') } const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } return \u003ch1\u003eHello {name + getExclamationMarks(enthusiasmLevel)}\u003c/h1\u003e } } export default Hi 然后在 ./src/app.tsx 里把 Hello 组件挂载上就可以了。 import './App.css' import Hello from './components/Hello' import Hi from './components/Hi' const App = () =\u003e { const name: string = 'React.js' return ( \u003cdiv className='App'\u003e \u003cheader className='App-header'\u003e \u003cHello name={name} /\u003e \u003cHi name='TypeScript' /\u003e \u003c/header\u003e \u003c/div\u003e ) } export default App 这样就算是完成了使用 TS 来建立 React 组件啦。 ","date":"2022-06-28","objectID":"/reactwithts/:2:1","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"1. React 没有解决的问题 React 本身只是一个 DOM 的抽象层，使用组件构建 Virtual DOM。 如果需要开发大应用，还需要解决 组件件通信——组件之间如何交换数据 数据流——数据如何和 View 串联起来，路由和数据如何绑定？如何编写异步逻辑….. ","date":"2022-06-13","objectID":"/dvanote/:1:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.1 通信问题 React 组件有以下几个通信对象 子组件 父组件 其他组件 React 中向子组件传递信息可以直接通过 this.props 传递，例如： class Son extends React.Component { render() { return \u003cinput onChange={this.props.onChange}/\u003e; } } class Father extends React.Component { constructor() { super(); this.state = { son: \"\" } } changeHandler(e) { this.setState({ son: e.target.value }); } render() { return \u003cdiv\u003e \u003cSon onChange={this.changeHandler.bind(this)}/\u003e \u003cp\u003e这里显示 Son 组件的内容：{this.state.son}\u003c/p\u003e \u003c/div\u003e; } } ReactDOM.render(\u003cFather/\u003e, mountNode); ","date":"2022-06-13","objectID":"/dvanote/:1:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.2 数据流问题 主流的数据流解决方案有： Flux：单向数据流，以 Redux 为代表 Reactive：响应式数据流，以 Mobx 为代表 ","date":"2022-06-13","objectID":"/dvanote/:1:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2. dva 是什么 ","date":"2022-06-13","objectID":"/dvanote/:2:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.1 dva 应用的最简结构 import dva from 'dva'; const App = () =\u003e \u003cdiv\u003eHello dva\u003c/div\u003e; // 创建应用 const app = dva(); // 注册视图 app.router(() =\u003e \u003cApp /\u003e); // 启动应用 app.start('#root'); ","date":"2022-06-13","objectID":"/dvanote/:2:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.2 数据流 ","date":"2022-06-13","objectID":"/dvanote/:2:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.3 核心概念 State：一个对象，保存整个应用的状态 View：React 组件构成的视图层 Action：一个对象，描述事件 connect：一个函数，绑定 State 到 View dispatch：一个函数，发送 Action 到 State 2.3.1 State 和 View State 是存储数据的地方，收到 Action 之后会更新数据。 View 就是 React 组件构成的 UI 层，从 State 获取到数据之后，渲染成 HTML 页面。只要 State 有变化，View 就会自动更新。 2.3.2 Action Action 是用来描述 UI 层的一个事件 { type: 'click-submit-button', payload: this.form.data } 2.3.4 connect 绑定 State 到 View import { connect } from 'dva'; function mapStateToProps(state) { return { todos: state.todos }; } connect(mapStateToProps)(App); connect() 返回的也是一个 React 组件，通常称为容器组件。因为它是原始的 UI 组件的容器，即在外面包了一层 State。 connect() 方法传入的第一个参数是 mapStateToProps 函数，它会返回一个对象，用户建立 State 到 Props 的映射关系。 2.3.5 dispatch dispatch() 用来将 Action 发送给 State dispatch({ type: 'click-submit-button', payload: this.form.data }) dispatch() 不是从石头蹦出来的，而是被 connect() 的组件会自动在 props 中拥有 dispatch() 方法。 connect() 的数据又是从哪来的？ 2.3.6 Model // 创建应用 const app = dva() // 注册 Model app.model({ namespace: 'count', state: 0, reducers: { add(state) { return state + 1 } }, effects: { *addAfter1Second(action, { call, put }) { yield call(delay, 1000) yield put({ type: 'add' }) } } }) // 注册 View app.router(() =\u003e \u003cConnectedApp /\u003e); // 启动 app.start('#root') 数据流 2.3.6.1 Model 对象的属性 namespace：当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成。 state：该 Model 当前的状态。数据都保存在这里。 reducers：Action 处理器，处理同步动作，用来计算最新的 State。 effects：Action 处理器，处理异步动作。 2.3.7 Reducer Reducer 是 Action 处理器，用来处理同步操作，可以看作是 state 的计算器。它的作用是根据 Action，从上一个 State 算出当前的 State。 2.3.8 Effect Action 处理器，处理异步动作，基于 Redux-saga 实现，Effect 指的是副作用。根据函数式编程，计算意外的操作都属于 Effect。 2.3.9 Generator Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步还是同步）。 2.3.10 call 和 put dva 提供多个 effect 函数内部的处理函数，比较常用的有 call() 和 put()。 call：执行异步函数 put：发出一个 Action，类似于 dispatch() ","date":"2022-06-13","objectID":"/dvanote/:2:3","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"不知不觉从五月又到末尾了，随着年龄的增长新的一年收获到总是比过往一年的要多，而五月恰恰是一年里我最喜欢的一个月份，聊聊在 2022 年的 5 月我都做了些什么吧。 未来规划上： 在这个 5 月里我不断的问自己该学什么/做什么才能提升自己未来的竞争力。在现在 COVID-19 蔓延的情况下，伴随的是深圳封城、上海停工两个月、手机出货量大跌、互联网大厂裁员等等消息，作为一个即将要毕业的大大学生不得不担忧起自己的未来。 很遗憾，我并没有能力去改变这个世界，我能做的只有去投资自己。这也是我在大学生涯唯一能做的事情了。我不喜欢用“卷”这个词去形容一个人努力学习，都是成年人了，应该都会知道想现在做的每一件都是为了以后能够过上好一些的生活。所以我开始为了工作而学习，在这也分享一下我是如何知道自己该学什么的：找到自己喜欢做的-\u003e去招聘网站上看这个岗位需要满足什么条件-\u003e学习。这样保证了自己学习的知识都能帮到自己的就业啦。 生活习惯上： 看了老石的这期视频我开始听更多的播客，确实是收获到许多不一样的的视角，以前看待科技公司都是以爱好去看的只看和分析他们的产品，却没有深入去了解为什么这个公司能做出来这样的产品来，用碎片化的时间去开阔自己的视野真的是一件性价比十分高的事情。 现阶段做了什么： 5 月开了不少的 GitHub 仓库作为记录学习过程，基本上是把现在在学的东西都建了一个仓库。也开始学着给自己的项目写英文文档（虽然我英语真的很差😭）；学习方式也从之前的看视频转向看官方文档了，看个框架的教程长短四十小时，看完敲完差不多得两个星期，花时间不说，教程里的一些代码规范也远不如官方文档的。 总结一下 5 月的关键词： 了解大环境 了解自己该学什么才能提升自己的竞争力 投资自己 开阔视野 优化自己的学习流程 至于为什么不想着创业：顺大势，逆小势。 ","date":"2022-05-28","objectID":"/2022maynote/:0:0","tags":null,"title":"五月小记","uri":"/2022maynote/"},{"categories":null,"content":"Hi，作为一个初次学习 React 的小白在了解了state和props之后就可以快乐的在父组件中传递数据给子组件，然后在子组件里使用父组件的回调函数去修改父组件的state了。但是在兄弟组件再像这样传递数据就会变得很麻烦了，父组件需要分别传递回调函数和数据给两个子组件，然后子组件再调用相应的属性和回调才能传递数据。 比如说要实现一个在Search组件和List 组件之间传递数据： // App 组件 class App extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 更新 App 的 state；传递给 Search 组件 updateAppState = (stateObj) =\u003e { this.setState( stateObj ) } render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch updateAppState={this.updateAppState}/\u003e \u003cList {...this.state}/\u003e \u003c/div\u003e ); } } // List 组件 class List extends Component { render() { const {users, isFirst, isLoading, err} = this.props return ( \u003cdiv className=\"row\"\u003e { // 根据父组件中的 state 来选择展示页面 isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } // Search 组件 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 发送请求前通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, err: error.message}) } ); } }为了在两个组件之间传递数据我们不得不通过父组件`App`给两个组件传递函数和属性，明明是两个兄弟组件传递起数据来别别扭扭的感觉是有仇一样的组件之间的交流全靠父组件。这样在组件之间传递数据的方式决不是一个好的选择，于是乎就有了**消息订阅与发布机制**，[PubSub.js](https://github.com/mroderick/PubSubJS) 就是这样的一个工具库。 README 就有 Example 来知指导我们怎么下载和导入，在这就不多赘述。安装、导入之后就可以开始重构我们的代码了。 先考虑 App 组件。App 组件中的state部分是为了在两个子组件传递数据才设置的，现在可以直接在两个组件之间传递数据，而在Search组件中需要通过数据来更新展示页面所以可以把 App 组件中的state部分剪切到Search组件中；数据都到了Search组件中那么原来为了修改state的函数updateAppState也就不需要了；对应的也不需要再往子组件里传递props了。 class App extends Component { render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch /\u003e \u003cList /\u003e \u003c/div\u003e ); } } 接下来我们需要将Search组件中得到的数据传递到List组件。在这个关系中Search的发送方对应 PubSub 关系中的 puhlisher，List对应的是 subscriber。我们在这个项目中只需要知道怎么订阅和取消订阅即可，文档中对于的部分为 Basic example 和 Cancel specific subscription。 // 其中的 msg 是订阅消息的名称，data 是传递的数据 var mySubscriber = function (msg, data) { console.log(msg, data); }; // 先推送后订阅 // 推送一个订阅名称为 MY TOPIC 的消息，内容为 hello world! PubSub.publish('MY TOPIC', 'hello world!'); // 创建一个 token 接收来自 MY TOPIC 推送 var token = PubSub.subscribe('MY TOPIC', mySubscriber); // 根据 token 取消订阅消息 PubSub.unsubscribe(token); 在知道了怎么推送/订阅消息之后我们还要考虑什么时候订阅和取消订阅推送，正常的逻辑是在这个组件加载染到页面时才订阅消息，组件被卸载后就取消订阅。所以我们就可以在componentDidMount中订阅推送，在componentWillUnmount中取消订阅。到了这我们就可以放心的去重构List和Search中的代码了 List组件重构后 class List extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 组件被挂载时订阅 componentDidMount() { this.token = PubSub.subscribe('MY TOPIC', (msg, data) =\u003e { this.setState(data) }) } // 组件被卸载时取消订阅 componentWillUnmount() { PubSub.unsubscribe(this.token) } render() { const {users, isFirst, isLoading, err} = this.state return ( \u003cdiv className=\"row\"\u003e { isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } Search组件重构后 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, err: error.message}) } ) } render() { return ( // 页面内容 ); } } 经过测试重构后的代码的功能和原来的代码保持一致但是代码和逻辑都","date":"2022-04-21","objectID":"/react-component-communication/:0:0","tags":null,"title":"React组件间通信","uri":"/react-component-communication/"},{"categories":null,"content":"我自己拥有的第一台电脑苹果第一台搭载自研桌面级处理的 MacBook，2020 年它带着光环而来。搭载全新的 Apple Silicon、10 小时续航、统一内存、超低功耗、Rosetta2、桌面级处理器最先进的制程。其他一切都是原来的样子。加上了 T2 芯片的主板，意味着这台电脑从第一次开机的时候所有的数据都是加密过的，数据丢失就不可恢复。统一内存架构将内存集成到 SoC 上的做法彻底关闭了 Mac mini 升级硬件的大门至于 MacBook 已经习惯它不能自行升级任何配置了。所以只能买购买的时候花天价升级配置。我的MacBook 只把内存升级到了 16G 就多花了 ¥1500。 自 20 年 12 月以来我已经用了这台 MacBook 一年半的时间了。当我的室友在打王者荣耀的时候我用它学习 C++；当我的室友在考前突击的时候我用它搭建了个人网站；我在这台电脑上写下了第一篇博客，创建了第一个 steam 账号。 ","date":"2022-03-09","objectID":"/macbookpro/:0:0","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"Enter the macOS 不能说 macOS 比 Windows 好但是如果你是第一次接触电脑 macOS 绝对要比 Windows 更容易上手。 macOS Big Sur 之后的设计风格更加接近移动端 没有控制面板 开箱即用的触控板手势 大量的非线性动画 不需要找怎么显示桌面图标 更多细节快捷操作的操作 macOS 和 Windows 官网都提供相应的使用手册虽然里面的完成一些功能的步骤是有些复杂的但是对于初次上手的新手真的是非常友好了，有了这个就可以不用到什么论坛、微博、知乎去求助。可以说看完这个再结合自己的操作绝对比大部分的网友更懂 macOS / Windows。在初次上手时很多操作我就参考了《macOS 使用手册》，对应的 Windows 也有官方的文档《Windows 帮助和学习》。 ","date":"2022-03-09","objectID":"/macbookpro/:0:1","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"硬件完成度 从 MacBook Pro 2016 到 MacBook Pro 2020 的外观几乎是没有变化，没有变化说明现在的模具稳定性没有什么大问题了但这个模具真的是用了有点久了。几乎一致的模具的内部藏着的就是本次最大的升级： Apple Silicon on Mac 统一内存架构 第一颗 5nm 桌面级处理器 MacBook 最强的集成显卡 雷电4 / USB 4 一天办公需求的续航 十分冷静的核心 大部分的场景下可以把搭载 M 系列的 Mac 当作之前搭载 Intel 的 Mac 一般使用只是发热低了许多。M1 没有因为功耗低在性能上做出太多的妥协，在你需要性能的时候它也不必之前的 MacBook 弱；更强的能耗比表现使其续航可以满足一天的办公需求。M1 芯片使得 MacBook 在市场成为一个独特的存在也走出了自己的一条路。需要注意的是 M1 独特的硬件架构不是适合所有人，在买所有 Mac 之前一定要清楚自己拿电脑是来做些什么的，一些人用上 M1 或许能让生产力提高；一些人或许面对的就是需要的软件在这个平台上根本没有。也不是所有的人都用的惯 macOS。 用了这么久的 M1，发现它的性能对于我来说现阶段是发挥不出它全部的实力除了觉得内存有点不太够用（选 Mac 时有预算尽量还是加在内存上；如果是定点办公闪存用靠雷电接口外接一点问题都没有）其他方面真的是非常够了。 今天看到了 M1 MAX 胶水拼接成了一块 M1 Ultra，在 2020 年我绝对想不到 M1 系列能如此的残暴：初次登场轻薄本中无敌的能耗比；Pro 、 Max 大幅度升级 GPU；最后的 Ultra 直接 Fusion。M1 都到 Ultra 了都没登陆到 Mac Pro 上或许下一代还有定位更高的？可能吧，让我们一起期待下一世代的 Apple Silicon。 ","date":"2022-03-09","objectID":"/macbookpro/:0:2","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"软件完成度 有自己的操作系统就是舒服，早在 2005 苹果就推出了 Universal Binary 和 Rosetta：为了从 PowerPC 过渡到 Intel 做准备。当时从 ARM -\u003e X86 的经验也让这次 X86 -\u003e ARM 变的更加的顺利，最明显的一点就是在搭载 M1 的 Mac 一发布就有不上第三方的软件完成了原生的适配。不仅如此，在 App Store 里还可以下载 iOS/iPadOS 的软件了虽然不是所有软件都支持但至少有了可以做到的能力，让 macOS 的生态和移动端更加紧密。（说句题外话：也希望能在未来的 WWDC 上看到 iPadOS 中能有更多关于内容生产的部分吧，去年的 iPad 的 playgrounds 已经可以写 swiftUI 的软件就是一个很好的开始。） 说完了为了 Apple Silicon 做出的适配再说说 macOS 本身。macOS 本就是一个 Unix 系统，自带的终端就默认的shell就是zsh。 在 Mac 上的 homebrew，可以直接通过终端下载软件和环境如果缺少对应的依赖也会自动下载好。比如这个博客的框架就是用 homebrew 下载的：brew install hugo，一行命令即可。 再来就是 macOS 中安装 Window。曾经我也对这个充满疑问：为什么在 macOS 里还要安装 Windows？？？后来才知道是我年轻了 —— 一些软件在 macOS 里根本没有。 如果你是大学生在不知道自己未来的学习需要用到什么软件的时候最好还是选择购买一台 Windows 的电脑，因为无法保证每个人都买得起 Parallels Desktop 虚拟机安装 Windows，买得起 Parallels Desktop 也不能保证需要的软件能运行在 arm 架构上或者说是流畅度可用。虽然的 M1 的 Mac 能耗比的优势巨大但是之前的 Intel Mac 还是有优势在的如果你需要那样的生产环境 Intel 的 Mac 还是很值得购买。 除却 Rosetta2 和 Universal Binary 之外 macOS 也从原先的拟物化设置变为了和 iOS 一样的扁平中带些拟物的化设计，比起之前更像移动端的设计风格了也让我这种 macOS 小白在 2020 年第一次使用 macOS 都没有感到一丝的不适应，至少不会出现不知道在哪显示桌面图标…… 不过当然了该有的 bug 一个都不会少：中文输入法卡顿、Safari 闪退等等问题（具体的问题根据使用场景的不同也都不一样）。如果安装了 beta 版的操作系统会更加的糟糕，不过没事别升级 beta 版系统。 ","date":"2022-03-09","objectID":"/macbookpro/:0:3","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"体验和感受 用了这么久的电脑早就习惯了它的操作逻辑也已经没有了刚拿到上手的新奇劲，现在就把它当作一个无情工具使用，性能够用、便携、续航强、编译起代码来一点都不哆嗦。电脑买来总是拿去干活的，如果它能让你工作流的效率提升那就买吧多赚的钱都购买好几台了电脑了。我现在希望的是它不要出问题：苹果的维修价格实在是太感人了。 我听说新 Mac 是造梦引擎，可我手机的这台已经是了呀！ ","date":"2022-03-09","objectID":"/macbookpro/:0:4","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"从高中开始就很想搭建一个自己的博客网站觉得这是一件特别酷的事情：在自己的网站上介绍自己的作品、分享自己产品体验又或是记录自己的碎碎念……虽然每次建站都会遇到坑但把从网站 localhost 推到 GitHub Pages 还是很高兴的。 之前的博客框架是 Gridea，每次同步都很糟心处于一种薛定谔的状态不过 Gridea 还是很适合少折腾专注写作的小伙伴。这次建站就换成 Hugo 来驱动，Hugo 是由 Go 语言编写的静态博客框架，可惜的是想要的域名在国内无法备案、Github Pages 在国内的访问处于一种很迷的的状态，不过这都不影响我写博客之后会在本站上更新一些自己做的小项目和数码产品的体验以及碎碎念。 祝我玩的开心！ ","date":"2022-02-11","objectID":"/helloworld/:0:0","tags":null,"title":"Hello world","uri":"/helloworld/"}]