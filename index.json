[{"categories":null,"content":"const 是为了解决什么问题？ 有时候我们希望定义这样一种变量，它的值不能被改变。例如，用一个变量来表示缓冲区的大小。使用变量的好处是当我们觉得缓冲区的大小不再合适的时，很容易对其进行调整。另一方面，也随时警惕防止程序一不小心改变了这个值。为了满足这一要求，可以使用关键字 const 对变量的类加以限定： const int BUFSIZE = 512; 以上便是 const 在《C++ Primer》中的解释。 第一次看书的时候觉得 const 不就是定义一个常量用的东西，没啥好关注的。直到写出 const int x = 10; 和 int const x = 10 一时竟不知道其区别是什么，于是决定再翻翻《C++ Primer》看一下 const 的使用方法，也解决一下心中的困惑。（还顺便发现 LoveIt 主题一个 bug：代码块中不能识别 C/C++ 代码） ","date":"2022-07-31","objectID":"/aboutconst/:1:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的引用 可以把引用绑定到 const 对象上，一般称之为对常量的引用（reference to const)，和普通引用唯一不同的是，对常量的引用不能改变它所绑定的对象： const int obj = 1024; const int \u0026r1 = obj; // 正确：引用及其对象都是常量 r1 = 512; // 错误：常量引用不可改变其绑定的对象 int \u0026r2 = obj; // 错误：试图让一个非常量引用指向一个常量对象 int i = 1024; const int \u0026r3 = i; // 正确：对 const 的引用可以引用一个非 const 的对象 r3 = 0; // 错误：r3 是一个常量引用 ","date":"2022-07-31","objectID":"/aboutconst/:2:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 和指针 与引用一样，也可以领指针指向常量对象，类似于对常量的引用，**指向常量的指针（pointer to const）**不能用于改变其所指向对象的值： const double pi = 3.14; double *p2Pi = \u0026pi; // 错误：p2Pi 是一个普通指针 const double *cp2Pi = \u0026pi; // 正确：cp2Pi 可以指向一个 double 常量 *cp2Pi = 3.1415; // 错误：指向常量的指针不能用于改变其所指向对象的值 ","date":"2022-07-31","objectID":"/aboutconst/:3:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 指针 以上都是些开胃小菜，下面的内容会对 const 有了一个新的认识。 指针是一个对象，所以**常量指针（const pointer）**必须初始化，而且一旦初始化指针指向的地址就不可以改变了。把 * 放在 const 关键字之前就说明该指针是一个常量指针。 double pi = 3.14; const double *const p2Pi = \u0026pi; // p2Pi 是一个指向常量对象的常量指针 int num = 1024; int *const currNum = \u0026num; // currNum 将一直指向 num 这样的书写方式也隐含着：不变的指针本地的值而非指向的那个值。 想要弄清楚这些含义最好的方式就是从从右向左看。此例中：离 currNum 最近的符号是 const，意味着这是一个常量对象，下一个符号是 *，意思是 currNum 是一个常量的指针，最后的类型部分确定了常量指针指向对象的类型。类似的 p2Pi 就可以解读为一个指向常量的指针常量。 指针本身是一个常量并不意味着不能通过指针修改对象的值，能否这样做取决于指向对象的类型。 ","date":"2022-07-31","objectID":"/aboutconst/:3:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"const 的位置 指针本身使用过对象，它可以指向另外一个对象。所以，指针本身是不是常量以及指针所指向的是不是一个常量就是两个独立的问题。用名词**顶层 const（top-level const）表示指针本身是一个常量，而用底层 const（low-level const）**表示指针指向的对象是一个常量。 double pi = 3.14; const double d = 2.0; // 不能修改 d 的值，这是一个顶级 const const double *p1 = \u0026pi; double *const p2 = \u0026pi; const double *p3 = \u0026pi; *p1 = 3.1415; // 错误：p1 是指向常量的指针（底层 const） p2 = \u0026d; // 错误：p2 是指针常量，不能修改指向的对象（顶层 const） *p3 = 10; // 错误：不允许改变 *p3，p3 是一个指向常量的指针 const double *const p4 = p2; // 靠右的 const 是顶层 const，靠左的是 底层 const const double \u0026r = pi; // 用于声明应用的 const 都是底层 const 如果是在变量中使用了顶/低层 const： const int x = 10; int const x = 10; 按照前面的定义可以说这两个声明的意思是一样的，定义了一个变量名为 x，值等于 10 的一个常量。两种方式都可以声明一个常量，我还是习惯于些 const int x = 10。 ","date":"2022-07-31","objectID":"/aboutconst/:3:2","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"函数中的 const 当形参是 const 时，如前面所述，顶层 const 作用于对象本身： const double pi = 3.14; double num = pi; // 正确：拷贝 pi 时忽略其顶层 const double *const p = \u0026num; // 错误：const 是顶层的，不能给 p 复制 *p = 0; // 正确：通过 p 改变 num 是合法的: =\u003e num = 0 和其他初始化过程一样，当实参初始化形参时会忽略其顶层 const。换句话说，当形参顶层有 const 时，传给它的值可以是常量也可以是非常量。 void foo(const int \u0026num); void foo(int \u0026num); // 错误：因为前一个函数顶层参数被忽略了，所以这两个函数的参数列表是一样的 ","date":"2022-07-31","objectID":"/aboutconst/:4:0","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"class 中的 const 函数 假设我们现在有这样一个 class： #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() { return stk.size(); } private: std::vector\u003cstring\u003e stk; }; 还有这样一个函数： int getStackSize(const Stack *stk) { return stk-\u003esize(); } 因为 stk 是一个 const reference 参数，因此在调用 getStackSize() 的时候应保证其不会修改 stk 的值，但是在 stk 上调用的每一个方法都有可能会影响 stk 的值，我们必须在成员函数上标注 const 来告诉编译器：Hi，编译器，在 Stack 对象调用 size() 方法的时候不会修改其对象的值: #include \u003cstring\u003e #include \u003cvector\u003e using std::string; using std::vector; class Stack { public: int size() const { // const 修饰符紧接在函数参数列表之后 return stk.size(); } private: std::vector\u003cstring\u003e stk; }; ","date":"2022-07-31","objectID":"/aboutconst/:4:1","tags":null,"title":"const 的困惑","uri":"/aboutconst/"},{"categories":null,"content":"从前后端分离开发说起 都说前后端开发要分离，而前后端分离的重点就是前后端独立可运行，那在后端接口没有返回数据的情况下来完成前端数据的获取呢？答案就是使用 Mock 数据来模拟预先与后端约定好的接口数据，来作为开发时的测试数据。 ","date":"2022-07-22","objectID":"/mockdata/:0:1","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"Mock 数据 什么是 Mock 数据 Mock.js 是一款模拟数据生成器，可以生成模拟数据来让前端开发独立于后端进行开发，帮助编写单元测试。提供了以下模拟功能： 根据模版生产模拟数据 模拟 Ajax 请求，生成并返回模拟数据 基于 HTML 模版生成模拟数据 使用 Mock 数据 安装 yarn add mockjs 使用 import Mock from 'mockjs' const Dashboard = Mock.mock({ 'sales|8': [ { 'name|+1': 2008, 'Clothes|200-500': 1, 'Food|180-400': 1, 'Electronics|300-550': 1, }, ], cpu: { 'usage|50-600': 1, space: 825, 'cpu|40-90': 1, 'data|20': [ { 'cpu|20-80': 1, }, ], }, ... }) 这个项目所有的数据都是由 Mock.js 生成的，在 Umi 项目中，/mock 文件夹里的所有文件都被视为 Mock 数据文件。 在 /mock 里的文件，最后都有一行 module.exports = { } /mock/dashboard.js module.exports = { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) }, } 这段代码的意思是生成了一个 GET 方法，地址为 localhost:port/APIPrefix/dashboard 的后端接口，使用 Postman 等工具也可以测试的出来返回结果。 同样的也可以使用 ESM 来导出： export default { [`GET ${ApiPrefix}/dashboard`](req, res) { res.json(Dashboard) } } Mock 数据生成规则详情见 Mock.js wiki ","date":"2022-07-22","objectID":"/mockdata/:0:2","tags":null,"title":"Mock 数据","uri":"/mockdata/"},{"categories":null,"content":"为什么要使用 TypeScript？ JS（JavaScript）是一门功能强大的语言，但是作为一门动态类型语言有时候简直是在浪费 IDE 强大的补全功能，就因为它是弱类型的语言，IDE 不能准确的推断出对象的类型，从而进行准确的提示。这一点对 VSCode 这种文本编辑器影响愈大。 TS（TypeScript）作为 JS 的一个超集，就和它的名字一样，为 JS 添加了 Type。作为一门静态语言，毫无疑问对 IDE 的语法补全有出色的帮助。别的优点不提，在 IDE 中的补全更强就是使用 TS 的一大理由，而且类型本身就是一种注释，哪怕需要添加更多的代码。 ","date":"2022-06-28","objectID":"/reactwithts/:1:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"在 React 中使用 TS 新建一个 React app 最简单的方式当然是使用 CRA 的 TS 模版了。 npx create-react-app my-ts-app --template typescript 打开项目，目录结构为： ├── README.md ├── node_modules ├── package-lock.json ├── package.json ├── public ├── src └── tsconfig.json 打开 /src 会发现 原来的 .jsx 文件的都变成了 .tsx。 ","date":"2022-06-28","objectID":"/reactwithts/:2:0","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"创建一个 TS 组件 import { useState, useEffect } from \"react\"; // Type with props export interface HelloProps { name: string; enthusiasmLevel?: number; } const Hello = ({ name, enthusiasmLevel = 1 }: HelloProps) =\u003e { const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } // Hooks with TS // 将 message 的类型设置为 string const [message, setMessage] = useState\u003cstring\u003e('') useEffect(() =\u003e { setMessage(`Hello ${name}` + getExclamationMarks(enthusiasmLevel)) }, [enthusiasmLevel, name]) return ( \u003cdiv\u003e \u003ch1\u003e{ message }\u003c/h1\u003e \u003c/div\u003e ); }; export default Hello; 注意到我们定义了一个 HelloProps 类型，它指定了这个组件需要用到的属性。在接受参数的时候我们为参数加上类型 HelloProps，一旦定义了类型，那么父组件就一定需要传递类型中的属性给子组件，否则将会报错。这样我们在 Hello 组件里接受到的参数就都是有类型的了。 同样的我们也可以选用类式组件 // src/components/Hi.tsx // 只是组件类型和 Hello.tsx 不同，其他都是一样的 import React from 'react' export interface HiProps { name: string enthusiasmLevel?: number } // React.Component\u003cHiProps, object\u003e 相当于 React 的泛型 // 这里的 HiProps 是 this.props 类型 class Hi extends React.Component\u003cHiProps, object\u003e { render() { const { name, enthusiasmLevel = 1 } = this.props if (enthusiasmLevel \u003c= 0) { throw new Error('You could be a little more enthusiastic. :D') } const getExclamationMarks = (numChars: number): string =\u003e { return Array(numChars + 1).join('!') } return \u003ch1\u003eHello {name + getExclamationMarks(enthusiasmLevel)}\u003c/h1\u003e } } export default Hi 然后在 ./src/app.tsx 里把 Hello 组件挂载上就可以了。 import './App.css' import Hello from './components/Hello' import Hi from './components/Hi' const App = () =\u003e { const name: string = 'React.js' return ( \u003cdiv className='App'\u003e \u003cheader className='App-header'\u003e \u003cHello name={name} /\u003e \u003cHi name='TypeScript' /\u003e \u003c/header\u003e \u003c/div\u003e ) } export default App 这样就算是完成了使用 TS 来建立 React 组件啦。 ","date":"2022-06-28","objectID":"/reactwithts/:2:1","tags":null,"title":"React With TS","uri":"/reactwithts/"},{"categories":null,"content":"1. React 没有解决的问题 React 本身只是一个 DOM 的抽象层，使用组件构建 Virtual DOM。 如果需要开发大应用，还需要解决 组件件通信——组件之间如何交换数据 数据流——数据如何和 View 串联起来，路由和数据如何绑定？如何编写异步逻辑….. ","date":"2022-06-13","objectID":"/dvanote/:1:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.1 通信问题 React 组件有以下几个通信对象 子组件 父组件 其他组件 React 中向子组件传递信息可以直接通过 this.props 传递，例如： class Son extends React.Component { render() { return \u003cinput onChange={this.props.onChange}/\u003e; } } class Father extends React.Component { constructor() { super(); this.state = { son: \"\" } } changeHandler(e) { this.setState({ son: e.target.value }); } render() { return \u003cdiv\u003e \u003cSon onChange={this.changeHandler.bind(this)}/\u003e \u003cp\u003e这里显示 Son 组件的内容：{this.state.son}\u003c/p\u003e \u003c/div\u003e; } } ReactDOM.render(\u003cFather/\u003e, mountNode); ","date":"2022-06-13","objectID":"/dvanote/:1:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"1.2 数据流问题 主流的数据流解决方案有： Flux：单向数据流，以 Redux 为代表 Reactive：响应式数据流，以 Mobx 为代表 ","date":"2022-06-13","objectID":"/dvanote/:1:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2. dva 是什么 ","date":"2022-06-13","objectID":"/dvanote/:2:0","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.1 dva 应用的最简结构 import dva from 'dva'; const App = () =\u003e \u003cdiv\u003eHello dva\u003c/div\u003e; // 创建应用 const app = dva(); // 注册视图 app.router(() =\u003e \u003cApp /\u003e); // 启动应用 app.start('#root'); ","date":"2022-06-13","objectID":"/dvanote/:2:1","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.2 数据流 ","date":"2022-06-13","objectID":"/dvanote/:2:2","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"2.3 核心概念 State：一个对象，保存整个应用的状态 View：React 组件构成的视图层 Action：一个对象，描述事件 connect：一个函数，绑定 State 到 View dispatch：一个函数，发送 Action 到 State 2.3.1 State 和 View State 是存储数据的地方，收到 Action 之后会更新数据。 View 就是 React 组件构成的 UI 层，从 State 获取到数据之后，渲染成 HTML 页面。只要 State 有变化，View 就会自动更新。 2.3.2 Action Action 是用来描述 UI 层的一个事件 { type: 'click-submit-button', payload: this.form.data } 2.3.4 connect 绑定 State 到 View import { connect } from 'dva'; function mapStateToProps(state) { return { todos: state.todos }; } connect(mapStateToProps)(App); connect() 返回的也是一个 React 组件，通常称为容器组件。因为它是原始的 UI 组件的容器，即在外面包了一层 State。 connect() 方法传入的第一个参数是 mapStateToProps 函数，它会返回一个对象，用户建立 State 到 Props 的映射关系。 2.3.5 dispatch dispatch() 用来将 Action 发送给 State dispatch({ type: 'click-submit-button', payload: this.form.data }) dispatch() 不是从石头蹦出来的，而是被 connect() 的组件会自动在 props 中拥有 dispatch() 方法。 connect() 的数据又是从哪来的？ 2.3.6 Model // 创建应用 const app = dva() // 注册 Model app.model({ namespace: 'count', state: 0, reducers: { add(state) { return state + 1 } }, effects: { *addAfter1Second(action, { call, put }) { yield call(delay, 1000) yield put({ type: 'add' }) } } }) // 注册 View app.router(() =\u003e \u003cConnectedApp /\u003e); // 启动 app.start('#root') 数据流 2.3.6.1 Model 对象的属性 namespace：当前 Model 的名称。整个应用的 State，由多个小的 Model 的 State 以 namespace 为 key 合成。 state：该 Model 当前的状态。数据都保存在这里。 reducers：Action 处理器，处理同步动作，用来计算最新的 State。 effects：Action 处理器，处理异步动作。 2.3.7 Reducer Reducer 是 Action 处理器，用来处理同步操作，可以看作是 state 的计算器。它的作用是根据 Action，从上一个 State 算出当前的 State。 2.3.8 Effect Action 处理器，处理异步动作，基于 Redux-saga 实现，Effect 指的是副作用。根据函数式编程，计算意外的操作都属于 Effect。 2.3.9 Generator Effect 是一个 Generator 函数，内部使用 yield 关键字，标识每一步的操作（不管是异步还是同步）。 2.3.10 call 和 put dva 提供多个 effect 函数内部的处理函数，比较常用的有 call() 和 put()。 call：执行异步函数 put：发出一个 Action，类似于 dispatch() ","date":"2022-06-13","objectID":"/dvanote/:2:3","tags":null,"title":"Dva 笔记","uri":"/dvanote/"},{"categories":null,"content":"不知不觉从五月又到末尾了，随着年龄的增长新的一年收获到总是比过往一年的要多，而五月恰恰是一年里我最喜欢的一个月份，聊聊在 2022 年的 5 月我都做了些什么吧。 未来规划上： 在这个 5 月里我不断的问自己该学什么/做什么才能提升自己未来的竞争力。在现在 COVID-19 蔓延的情况下，伴随的是深圳封城、上海停工两个月、手机出货量大跌、互联网大厂裁员等等消息，作为一个即将要毕业的大大学生不得不担忧起自己的未来。 很遗憾，我并没有能力去改变这个世界，我能做的只有去投资自己。这也是我在大学生涯唯一能做的事情了。我不喜欢用“卷”这个词去形容一个人努力学习，都是成年人了，应该都会知道想现在做的每一件都是为了以后能够过上好一些的生活。所以我开始为了工作而学习，在这也分享一下我是如何知道自己该学什么的：找到自己喜欢做的-\u003e去招聘网站上看这个岗位需要满足什么条件-\u003e学习。这样保证了自己学习的知识都能帮到自己的就业啦。 生活习惯上： 看了老石的这期视频我开始听更多的播客，确实是收获到许多不一样的的视角，以前看待科技公司都是以爱好去看的只看和分析他们的产品，却没有深入去了解为什么这个公司能做出来这样的产品来，用碎片化的时间去开阔自己的视野真的是一件性价比十分高的事情。 现阶段做了什么： 5 月开了不少的 GitHub 仓库作为记录学习过程，基本上是把现在在学的东西都建了一个仓库。也开始学着给自己的项目写英文文档（虽然我英语真的很差😭）；学习方式也从之前的看视频转向看官方文档了，看个框架的教程长短四十小时，看完敲完差不多得两个星期，花时间不说，教程里的一些代码规范也远不如官方文档的。 总结一下 5 月的关键词： 了解大环境 了解自己该学什么才能提升自己的竞争力 投资自己 开阔视野 优化自己的学习流程 至于为什么不想着创业：顺大势，逆小势。 ","date":"2022-05-28","objectID":"/2022maynote/:0:0","tags":null,"title":"五月小记","uri":"/2022maynote/"},{"categories":null,"content":"Hi，作为一个初次学习 React 的小白在了解了state和props之后就可以快乐的在父组件中传递数据给子组件，然后在子组件里使用父组件的回调函数去修改父组件的state了。但是在兄弟组件再像这样传递数据就会变得很麻烦了，父组件需要分别传递回调函数和数据给两个子组件，然后子组件再调用相应的属性和回调才能传递数据。 比如说要实现一个在Search组件和List 组件之间传递数据： // App 组件 class App extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 更新 App 的 state；传递给 Search 组件 updateAppState = (stateObj) =\u003e { this.setState( stateObj ) } render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch updateAppState={this.updateAppState}/\u003e \u003cList {...this.state}/\u003e \u003c/div\u003e ); } } // List 组件 class List extends Component { render() { const {users, isFirst, isLoading, err} = this.props return ( \u003cdiv className=\"row\"\u003e { // 根据父组件中的 state 来选择展示页面 isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } // Search 组件 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 发送请求前通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, err: error.message}) } ); } }为了在两个组件之间传递数据我们不得不通过父组件`App`给两个组件传递函数和属性，明明是两个兄弟组件传递起数据来别别扭扭的感觉是有仇一样的组件之间的交流全靠父组件。这样在组件之间传递数据的方式决不是一个好的选择，于是乎就有了**消息订阅与发布机制**，[PubSub.js](https://github.com/mroderick/PubSubJS) 就是这样的一个工具库。 README 就有 Example 来知指导我们怎么下载和导入，在这就不多赘述。安装、导入之后就可以开始重构我们的代码了。 先考虑 App 组件。App 组件中的state部分是为了在两个子组件传递数据才设置的，现在可以直接在两个组件之间传递数据，而在Search组件中需要通过数据来更新展示页面所以可以把 App 组件中的state部分剪切到Search组件中；数据都到了Search组件中那么原来为了修改state的函数updateAppState也就不需要了；对应的也不需要再往子组件里传递props了。 class App extends Component { render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch /\u003e \u003cList /\u003e \u003c/div\u003e ); } } 接下来我们需要将Search组件中得到的数据传递到List组件。在这个关系中Search的发送方对应 PubSub 关系中的 puhlisher，List对应的是 subscriber。我们在这个项目中只需要知道怎么订阅和取消订阅即可，文档中对于的部分为 Basic example 和 Cancel specific subscription。 // 其中的 msg 是订阅消息的名称，data 是传递的数据 var mySubscriber = function (msg, data) { console.log(msg, data); }; // 先推送后订阅 // 推送一个订阅名称为 MY TOPIC 的消息，内容为 hello world! PubSub.publish('MY TOPIC', 'hello world!'); // 创建一个 token 接收来自 MY TOPIC 推送 var token = PubSub.subscribe('MY TOPIC', mySubscriber); // 根据 token 取消订阅消息 PubSub.unsubscribe(token); 在知道了怎么推送/订阅消息之后我们还要考虑什么时候订阅和取消订阅推送，正常的逻辑是在这个组件加载染到页面时才订阅消息，组件被卸载后就取消订阅。所以我们就可以在componentDidMount中订阅推送，在componentWillUnmount中取消订阅。到了这我们就可以放心的去重构List和Search中的代码了 List组件重构后 class List extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 组件被挂载时订阅 componentDidMount() { this.token = PubSub.subscribe('MY TOPIC', (msg, data) =\u003e { this.setState(data) }) } // 组件被卸载时取消订阅 componentWillUnmount() { PubSub.unsubscribe(this.token) } render() { const {users, isFirst, isLoading, err} = this.state return ( \u003cdiv className=\"row\"\u003e { isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } Search组件重构后 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, err: error.message}) } ) } render() { return ( // 页面内容 ); } } 经过测试重构后的代码的功能和原来的代码保持一致但是代码和逻辑都","date":"2022-04-21","objectID":"/react-component-communication/:0:0","tags":null,"title":"React组件间通信","uri":"/react-component-communication/"},{"categories":null,"content":"我自己拥有的第一台电脑苹果第一台搭载自研桌面级处理的 MacBook，2020 年它带着光环而来。搭载全新的 Apple Silicon、10 小时续航、统一内存、超低功耗、Rosetta2、桌面级处理器最先进的制程。其他一切都是原来的样子。加上了 T2 芯片的主板，意味着这台电脑从第一次开机的时候所有的数据都是加密过的，数据丢失就不可恢复。统一内存架构将内存集成到 SoC 上的做法彻底关闭了 Mac mini 升级硬件的大门至于 MacBook 已经习惯它不能自行升级任何配置了。所以只能买购买的时候花天价升级配置。我的MacBook 只把内存升级到了 16G 就多花了 ¥1500。 自 20 年 12 月以来我已经用了这台 MacBook 一年半的时间了。当我的室友在打王者荣耀的时候我用它学习 C++；当我的室友在考前突击的时候我用它搭建了个人网站；我在这台电脑上写下了第一篇博客，创建了第一个 steam 账号。 ","date":"2022-03-09","objectID":"/macbookpro/:0:0","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"Enter the macOS 不能说 macOS 比 Windows 好但是如果你是第一次接触电脑 macOS 绝对要比 Windows 更容易上手。 macOS Big Sur 之后的设计风格更加接近移动端 没有控制面板 开箱即用的触控板手势 大量的非线性动画 不需要找怎么显示桌面图标 更多细节快捷操作的操作 macOS 和 Windows 官网都提供相应的使用手册虽然里面的完成一些功能的步骤是有些复杂的但是对于初次上手的新手真的是非常友好了，有了这个就可以不用到什么论坛、微博、知乎去求助。可以说看完这个再结合自己的操作绝对比大部分的网友更懂 macOS / Windows。在初次上手时很多操作我就参考了《macOS 使用手册》，对应的 Windows 也有官方的文档《Windows 帮助和学习》。 ","date":"2022-03-09","objectID":"/macbookpro/:0:1","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"硬件完成度 从 MacBook Pro 2016 到 MacBook Pro 2020 的外观几乎是没有变化，没有变化说明现在的模具稳定性没有什么大问题了但这个模具真的是用了有点久了。几乎一致的模具的内部藏着的就是本次最大的升级： Apple Silicon on Mac 统一内存架构 第一颗 5nm 桌面级处理器 MacBook 最强的集成显卡 雷电4 / USB 4 一天办公需求的续航 十分冷静的核心 大部分的场景下可以把搭载 M 系列的 Mac 当作之前搭载 Intel 的 Mac 一般使用只是发热低了许多。M1 没有因为功耗低在性能上做出太多的妥协，在你需要性能的时候它也不必之前的 MacBook 弱；更强的能耗比表现使其续航可以满足一天的办公需求。M1 芯片使得 MacBook 在市场成为一个独特的存在也走出了自己的一条路。需要注意的是 M1 独特的硬件架构不是适合所有人，在买所有 Mac 之前一定要清楚自己拿电脑是来做些什么的，一些人用上 M1 或许能让生产力提高；一些人或许面对的就是需要的软件在这个平台上根本没有。也不是所有的人都用的惯 macOS。 用了这么久的 M1，发现它的性能对于我来说现阶段是发挥不出它全部的实力除了觉得内存有点不太够用（选 Mac 时有预算尽量还是加在内存上；如果是定点办公闪存用靠雷电接口外接一点问题都没有）其他方面真的是非常够了。 今天看到了 M1 MAX 胶水拼接成了一块 M1 Ultra，在 2020 年我绝对想不到 M1 系列能如此的残暴：初次登场轻薄本中无敌的能耗比；Pro 、 Max 大幅度升级 GPU；最后的 Ultra 直接 Fusion。M1 都到 Ultra 了都没登陆到 Mac Pro 上或许下一代还有定位更高的？可能吧，让我们一起期待下一世代的 Apple Silicon。 ","date":"2022-03-09","objectID":"/macbookpro/:0:2","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"软件完成度 有自己的操作系统就是舒服，早在 2005 苹果就推出了 Universal Binary 和 Rosetta：为了从 PowerPC 过渡到 Intel 做准备。当时从 ARM -\u003e X86 的经验也让这次 X86 -\u003e ARM 变的更加的顺利，最明显的一点就是在搭载 M1 的 Mac 一发布就有不上第三方的软件完成了原生的适配。不仅如此，在 App Store 里还可以下载 iOS/iPadOS 的软件了虽然不是所有软件都支持但至少有了可以做到的能力，让 macOS 的生态和移动端更加紧密。（说句题外话：也希望能在未来的 WWDC 上看到 iPadOS 中能有更多关于内容生产的部分吧，去年的 iPad 的 playgrounds 已经可以写 swiftUI 的软件就是一个很好的开始。） 说完了为了 Apple Silicon 做出的适配再说说 macOS 本身。macOS 本就是一个 Unix 系统，自带的终端就默认的shell就是zsh。 在 Mac 上的 homebrew，可以直接通过终端下载软件和环境如果缺少对应的依赖也会自动下载好。比如这个博客的框架就是用 homebrew 下载的：brew install hugo，一行命令即可。 再来就是 macOS 中安装 Window。曾经我也对这个充满疑问：为什么在 macOS 里还要安装 Windows？？？后来才知道是我年轻了 —— 一些软件在 macOS 里根本没有。 如果你是大学生在不知道自己未来的学习需要用到什么软件的时候最好还是选择购买一台 Windows 的电脑，因为无法保证每个人都买得起 Parallels Desktop 虚拟机安装 Windows，买得起 Parallels Desktop 也不能保证需要的软件能运行在 arm 架构上或者说是流畅度可用。虽然的 M1 的 Mac 能耗比的优势巨大但是之前的 Intel Mac 还是有优势在的如果你需要那样的生产环境 Intel 的 Mac 还是很值得购买。 除却 Rosetta2 和 Universal Binary 之外 macOS 也从原先的拟物化设置变为了和 iOS 一样的扁平中带些拟物的化设计，比起之前更像移动端的设计风格了也让我这种 macOS 小白在 2020 年第一次使用 macOS 都没有感到一丝的不适应，至少不会出现不知道在哪显示桌面图标…… 不过当然了该有的 bug 一个都不会少：中文输入法卡顿、Safari 闪退等等问题（具体的问题根据使用场景的不同也都不一样）。如果安装了 beta 版的操作系统会更加的糟糕，不过没事别升级 beta 版系统。 ","date":"2022-03-09","objectID":"/macbookpro/:0:3","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"体验和感受 用了这么久的电脑早就习惯了它的操作逻辑也已经没有了刚拿到上手的新奇劲，现在就把它当作一个无情工具使用，性能够用、便携、续航强、编译起代码来一点都不哆嗦。电脑买来总是拿去干活的，如果它能让你工作流的效率提升那就买吧多赚的钱都购买好几台了电脑了。我现在希望的是它不要出问题：苹果的维修价格实在是太感人了。 我听说新 Mac 是造梦引擎，可我手机的这台已经是了呀！ ","date":"2022-03-09","objectID":"/macbookpro/:0:4","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"从高中开始就很想搭建一个自己的博客网站觉得这是一件特别酷的事情：在自己的网站上介绍自己的作品、分享自己产品体验又或是记录自己的碎碎念……虽然每次建站都会遇到坑但把从网站 localhost 推到 GitHub Pages 还是很高兴的。 之前的博客框架是 Gridea，每次同步都很糟心处于一种薛定谔的状态不过 Gridea 还是很适合少折腾专注写作的小伙伴。这次建站就换成 Hugo 来驱动，Hugo 是由 Go 语言编写的静态博客框架，可惜的是想要的域名在国内无法备案、Github Pages 在国内的访问处于一种很迷的的状态，不过这都不影响我写博客之后会在本站上更新一些自己做的小项目和数码产品的体验以及碎碎念。 祝我玩的开心！ ","date":"2022-02-11","objectID":"/helloworld/:0:0","tags":null,"title":"Hello world","uri":"/helloworld/"}]