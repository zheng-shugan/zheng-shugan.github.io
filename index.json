[{"categories":null,"content":"不知不觉从五月又到末尾了，随着年龄的增长新的一年收获到总是比过往一年的要多，而五月恰恰是一年里我最喜欢的一个月份，聊聊在 2022 年的 5 月我都做了些什么吧。 未来规划上： 在这个 5 月里我不断的问自己该学什么/做什么才能提升自己未来的竞争力。在现在 COVID-19 蔓延的情况下，伴随的是深圳封城、上海停工两个月、手机出货量大跌、互联网大厂裁员等等消息，作为一个即将要毕业的大大学生不得不担忧起自己的未来。 很遗憾，我并没有能力去改变这个世界，我能做的只有去投资自己。这也是我在大学生涯唯一能做的事情了。我不喜欢用“卷”这个词去形容一个人努力学习，都是成年人了，应该都会知道想现在做的每一件都是为了以后能够过上好一些的生活。所以我开始为了工作而学习，在这也分享一下我是如何知道自己该学什么的：找到自己喜欢做的-\u003e去招聘网站上看这个岗位需要满足什么条件-\u003e学习。这样保证了自己学习的知识都能帮到自己的就业啦。 生活习惯上： 看了老石的这期视频我开始听更多的播客，确实是收获到许多不一样的的视角，以前看待科技公司都是以爱好去看的只看和分析他们的产品，却没有深入去了解为什么这个公司能做出来这样的产品来，用碎片化的时间去开阔自己的视野真的是一件性价比十分高的事情。 总结一下 5 月的关键词： 了解大环境 了解自己该学什么才能提升自己的竞争力 投资自己 开阔视野 至于为什么不想着创业：顺大势，逆小势。 ","date":"2022-05-28","objectID":"/2022maynote/:0:0","tags":null,"title":"五月小记","uri":"/2022maynote/"},{"categories":null,"content":"Hi，作为一个初次学习 React 的小白在了解了state和props之后就可以快乐的在父组件中传递数据给子组件，然后在子组件里使用父组件的回调函数去修改父组件的state了。但是在兄弟组件再像这样传递数据就会变得很麻烦了，父组件需要分别传递回调函数和数据给两个子组件，然后子组件再调用相应的属性和回调才能传递数据。 比如说要实现一个在Search组件和List 组件之间传递数据： // App 组件 class App extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 更新 App 的 state；传递给 Search 组件 updateAppState = (stateObj) =\u003e { this.setState( stateObj ) } render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch updateAppState={this.updateAppState}/\u003e \u003cList {...this.state}/\u003e \u003c/div\u003e ); } } // List 组件 class List extends Component { render() { const {users, isFirst, isLoading, err} = this.props return ( \u003cdiv className=\"row\"\u003e { // 根据父组件中的 state 来选择展示页面 isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } // Search 组件 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 发送请求前通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 App 更新 state；通过调用父组件传递的函数更新父组件中的数据 this.props.updateAppState({isLoading: false, err: error.message}) } ); } } 为了在两个组件之间传递数据我们不得不通过父组件App给两个组件传递函数和属性，明明是两个兄弟组件传递起数据来别别扭扭的感觉是有仇一样的组件之间的交流全靠父组件。这样在组件之间传递数据的方式决不是一个好的选择，于是乎就有了消息订阅与发布机制，PubSub.js 就是这样的一个工具库。 README 就有 Example 来知指导我们怎么下载和导入，在这就不多赘述。安装、导入之后就可以开始重构我们的代码了。 先考虑 App 组件。App 组件中的state部分是为了在两个子组件传递数据才设置的，现在可以直接在两个组件之间传递数据，而在Search组件中需要通过数据来更新展示页面所以可以把 App 组件中的state部分剪切到Search组件中；数据都到了Search组件中那么原来为了修改state的函数updateAppState也就不需要了；对应的也不需要再往子组件里传递props了。 class App extends Component { render() { return ( \u003cdiv className=\"container\"\u003e \u003cSearch /\u003e \u003cList /\u003e \u003c/div\u003e ); } } 接下来我们需要将Search组件中得到的数据传递到List组件。在这个关系中Search的发送方对应 PubSub 关系中的 puhlisher，List对应的是 subscriber。我们在这个项目中只需要知道怎么订阅和取消订阅即可，文档中对于的部分为 Basic example 和 Cancel specific subscription。 // 其中的 msg 是订阅消息的名称，data 是传递的数据 var mySubscriber = function (msg, data) { console.log(msg, data); }; // 先推送后订阅 // 推送一个订阅名称为 MY TOPIC 的消息，内容为 hello world! PubSub.publish('MY TOPIC', 'hello world!'); // 创建一个 token 接收来自 MY TOPIC 推送 var token = PubSub.subscribe('MY TOPIC', mySubscriber); // 根据 token 取消订阅消息 PubSub.unsubscribe(token); 在知道了怎么推送/订阅消息之后我们还要考虑什么时候订阅和取消订阅推送，正常的逻辑是在这个组件加载染到页面时才订阅消息，组件被卸载后就取消订阅。所以我们就可以在componentDidMount中订阅推送，在componentWillUnmount中取消订阅。到了这我们就可以放心的去重构List和Search中的代码了 List组件重构后 class List extends Component { state = { users: [], // 初始化状态，users 是数组 isFirst: true, // 是否为第一次打开 isLoading: false, // 标识是否处于加载中 err: '', // 存储请求相关错误信息 } // 组件被挂载时订阅 componentDidMount() { this.token = PubSub.subscribe('MY TOPIC', (msg, data) =\u003e { this.setState(data) }) } // 组件被卸载时取消订阅 componentWillUnmount() { PubSub.unsubscribe(this.token) } render() { const {users, isFirst, isLoading, err} = this.state return ( \u003cdiv className=\"row\"\u003e { isFirst ? \u003ch2\u003e欢迎输入，输入关键词搜索\u003c/h2\u003e : isLoading ? \u003ch2\u003eLoading\u003c/h2\u003e : err ? \u003ch2 style={{color: 'red'}}\u003e{err}\u003c/h2\u003e: users.map((userObj) =\u003e { return( // 页面内容 ) }) } \u003c/div\u003e ); } } Search组件重构后 class Search extends Component { search = () =\u003e { // 获取输入（连续解构赋值+重命名 const {keywordElement: {value: keyword}} = this // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isFirst: false, isLoading: false}) // 发送网络请求 axios.get(`http://localhost:3000/api1/search/users?q=${keyword}`).then( response =\u003e { // 发送请求成功通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, users: response.data.items}) }, error =\u003e { // 发送请求失败通知 List 更新 state // 推送一个名为 MY TOPIC，内容是一个对象 PubSub.publish('MY TOPIC', {isLoading: false, err: error.message}) } ) } render() { return ( // 页面内容 ); } } 经过测试重构后的代码的功能和原来的代码保持一致但是代码和逻辑都更清楚了。 ","date":"2022-04-21","objectID":"/react-component-communication/:0:0","tags":null,"title":"React组件间通信","uri":"/react-component-communication/"},{"categories":null,"content":"我自己拥有的第一台电脑苹果第一台搭载自研桌面级处理的 MacBook，2020 年它带着光环而来。搭载全新的 Apple Silicon、10 小时续航、统一内存、超低功耗、Rosetta2、桌面级处理器最先进的制程。其他一切都是原来的样子。加上了 T2 芯片的主板，意味着这台电脑从第一次开机的时候所有的数据都是加密过的，数据丢失就不可恢复。统一内存架构将内存集成到 SoC 上的做法彻底关闭了 Mac mini 升级硬件的大门至于 MacBook 已经习惯它不能自行升级任何配置了。所以只能买购买的时候花天价升级配置。我的MacBook 只把内存升级到了 16G 就多花了 ¥1500。 自 20 年 12 月以来我已经用了这台 MacBook 一年半的时间了。当我的室友在打王者荣耀的时候我用它学习 C++；当我的室友在考前突击的时候我用它搭建了个人网站；我在这台电脑上写下了第一篇博客，创建了第一个 steam 账号。 ","date":"2022-03-09","objectID":"/macbookpro/:0:0","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"Enter the macOS 不能说 macOS 比 Windows 好但是如果你是第一次接触电脑 macOS 绝对要比 Windows 更容易上手。 macOS Big Sur 之后的设计风格更加接近移动端 没有控制面板 开箱即用的触控板手势 大量的非线性动画 不需要找怎么显示桌面图标 更多细节快捷操作的操作 macOS 和 Windows 官网都提供相应的使用手册虽然里面的完成一些功能的步骤是有些复杂的但是对于初次上手的新手真的是非常友好了，有了这个就可以不用到什么论坛、微博、知乎去求助。可以说看完这个再结合自己的操作绝对比大部分的网友更懂 macOS / Windows。在初次上手时很多操作我就参考了《macOS 使用手册》，对应的 Windows 也有官方的文档《Windows 帮助和学习》。 ","date":"2022-03-09","objectID":"/macbookpro/:0:1","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"硬件完成度 从 MacBook Pro 2016 到 MacBook Pro 2020 的外观几乎是没有变化，没有变化说明现在的模具稳定性没有什么大问题了但这个模具真的是用了有点久了。几乎一致的模具的内部藏着的就是本次最大的升级： Apple Silicon on Mac 统一内存架构 第一颗 5nm 桌面级处理器 MacBook 最强的集成显卡 雷电4 / USB 4 一天办公需求的续航 十分冷静的核心 大部分的场景下可以把搭载 M 系列的 Mac 当作之前搭载 Intel 的 Mac 一般使用只是发热低了许多。M1 没有因为功耗低在性能上做出太多的妥协，在你需要性能的时候它也不必之前的 MacBook 弱；更强的能耗比表现使其续航可以满足一天的办公需求。M1 芯片使得 MacBook 在市场成为一个独特的存在也走出了自己的一条路。需要注意的是 M1 独特的硬件架构不是适合所有人，在买所有 Mac 之前一定要清楚自己拿电脑是来做些什么的，一些人用上 M1 或许能让生产力提高；一些人或许面对的就是需要的软件在这个平台上根本没有。也不是所有的人都用的惯 macOS。 用了这么久的 M1，发现它的性能对于我来说现阶段是发挥不出它全部的实力除了觉得内存有点不太够用（选 Mac 时有预算尽量还是加在内存上；如果是定点办公闪存用靠雷电接口外接一点问题都没有）其他方面真的是非常够了。 今天看到了 M1 MAX 胶水拼接成了一块 M1 Ultra，在 2020 年我绝对想不到 M1 系列能如此的残暴：初次登场轻薄本中无敌的能耗比；Pro 、 Max 大幅度升级 GPU；最后的 Ultra 直接 Fusion。M1 都到 Ultra 了都没登陆到 Mac Pro 上或许下一代还有定位更高的？可能吧，让我们一起期待下一世代的 Apple Silicon。 ","date":"2022-03-09","objectID":"/macbookpro/:0:2","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"软件完成度 有自己的操作系统就是舒服，早在 2005 苹果就推出了 Universal Binary 和 Rosetta：为了从 PowerPC 过渡到 Intel 做准备。当时从 ARM -\u003e X86 的经验也让这次 X86 -\u003e ARM 变的更加的顺利，最明显的一点就是在搭载 M1 的 Mac 一发布就有不上第三方的软件完成了原生的适配。不仅如此，在 App Store 里还可以下载 iOS/iPadOS 的软件了虽然不是所有软件都支持但至少有了可以做到的能力，让 macOS 的生态和移动端更加紧密。（说句题外话：也希望能在未来的 WWDC 上看到 iPadOS 中能有更多关于内容生产的部分吧，去年的 iPad 的 playgrounds 已经可以写 swiftUI 的软件就是一个很好的开始。） 说完了为了 Apple Silicon 做出的适配再说说 macOS 本身。macOS 本就是一个 Unix 系统，自带的终端就默认的shell就是zsh。 在 Mac 上的 homebrew，可以直接通过终端下载软件和环境如果缺少对应的依赖也会自动下载好。比如这个博客的框架就是用 homebrew 下载的：brew install hugo，一行命令即可。 再来就是 macOS 中安装 Window。曾经我也对这个充满疑问：为什么在 macOS 里还要安装 Windows？？？后来才知道是我年轻了 —— 一些软件在 macOS 里根本没有。 如果你是大学生在不知道自己未来的学习需要用到什么软件的时候最好还是选择购买一台 Windows 的电脑，因为无法保证每个人都买得起 Parallels Desktop 虚拟机安装 Windows，买得起 Parallels Desktop 也不能保证需要的软件能运行在 arm 架构上或者说是流畅度可用。虽然的 M1 的 Mac 能耗比的优势巨大但是之前的 Intel Mac 还是有优势在的如果你需要那样的生产环境 Intel 的 Mac 还是很值得购买。 除却 Rosetta2 和 Universal Binary 之外 macOS 也从原先的拟物化设置变为了和 iOS 一样的扁平中带些拟物的化设计，比起之前更像移动端的设计风格了也让我这种 macOS 小白在 2020 年第一次使用 macOS 都没有感到一丝的不适应，至少不会出现不知道在哪显示桌面图标…… 不过当然了该有的 bug 一个都不会少：中文输入法卡顿、Safari 闪退等等问题（具体的问题根据使用场景的不同也都不一样）。如果安装了 beta 版的操作系统会更加的糟糕，不过没事别升级 beta 版系统。 ","date":"2022-03-09","objectID":"/macbookpro/:0:3","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"体验和感受 用了这么久的电脑早就习惯了它的操作逻辑也已经没有了刚拿到上手的新奇劲，现在就把它当作一个无情工具使用，性能够用、便携、续航强、编译起代码来一点都不哆嗦。电脑买来总是拿去干活的，如果它能让你工作流的效率提升那就买吧多赚的钱都购买好几台了电脑了。我现在希望的是它不要出问题：苹果的维修价格实在是太感人了。 我听说新 Mac 是造梦引擎，可我手机的这台已经是了呀！ ","date":"2022-03-09","objectID":"/macbookpro/:0:4","tags":null,"title":"我听说新 Mac 是造梦引擎？","uri":"/macbookpro/"},{"categories":null,"content":"从高中开始就很想搭建一个自己的博客网站觉得这是一件特别酷的事情：在自己的网站上介绍自己的作品、分享自己产品体验又或是记录自己的碎碎念……虽然每次建站都会遇到坑但把从网站 localhost 推到 GitHub Pages 还是很高兴的。 之前的博客框架是 Gridea，每次同步都很糟心处于一种薛定谔的状态不过 Gridea 还是很适合少折腾专注写作的小伙伴。这次建站就换成 Hugo 来驱动，Hugo 是由 Go 语言编写的静态博客框架，可惜的是想要的域名在国内无法备案、Github Pages 在国内的访问处于一种很迷的的状态，不过这都不影响我写博客之后会在本站上更新一些自己做的小项目和数码产品的体验以及碎碎念。 祝我玩的开心！ ","date":"2022-02-11","objectID":"/helloworld/:0:0","tags":null,"title":"Hello world","uri":"/helloworld/"}]